# 09d. Захист від дублювання коду

## 🚨 КРАСНА ЛІНІЯ: НІ ОДНОГО РЯДКА КОДУ БЕЗ ПЕРЕВІРКИ ІСНУЮЧОГО

**Проблема:** Агенти створюють дублюючий функціонал БЕЗ перевірки чи вже існує реалізація або фундамент для розширення.

**Рішення:** Обов'язковий Grep/Glob пошук ПЕРЕД будь-якими змінами коду.

---

## 🔍 ОБОВ'ЯЗКОВИЙ ПРОТОКОЛ ПЕРЕД БУДЬ-ЯКИМИ ЗМІНАМИ КОДУ

### ШАГ 1: ОБОВ'ЯЗКОВА ПЕРЕВІРКА ІСНУЮЧОГО ФУНКЦІОНАЛУ

Перед **БУДЬ-ЯКИМИ ЗМІНАМИ КОДУ** (створенням, зміною, розширенням) ОБОВ'ЯЗКОВО:

#### 1. Grep пошук за ключовими словами

```bash
# Шукати за назвою функції/класу/компонента
Grep(pattern="назва_функції|схожа_назва", path="src/", output_mode="files_with_matches")

# Шукати за схожою функціональністю
Grep(pattern="ключові_слова_функціоналу", path="src/", output_mode="files_with_matches")

# Шукати суміжні імплементації
Grep(pattern="related_functionality", path="src/", output_mode="files_with_matches")
```

**Приклад:**
```bash
# Задача: Створити QR-сканування
Grep(pattern="qr.*scan|scan.*qr|qrcode", path="src/")
```

#### 2. Glob пошук за патерном файлів

```bash
# Файли з схожими назвами
Glob(pattern="**/назва_компонента*.{ts,tsx,js,py}")

# Файли в схожих директоріях
Glob(pattern="**/lib/**/qr*.ts")

# Тестові файли для схожого функціоналу
Glob(pattern="**/__tests__/**/*qr*.test.ts")
```

**Приклад:**
```bash
# Задача: Створити QR-сканування
Glob(pattern="**/qr*.{ts,tsx}")
Glob(pattern="**/scanner*.{ts,tsx}")
Glob(pattern="**/*scan*.{ts,tsx}")
```

#### 3. Аналіз знайденого

**ОБОВ'ЯЗКОВО відповісти на питання:**
- ЩО вже реалізовано?
- ЧИ є фундамент для розширення?
- ЧИ потрібно створювати з нуля?
- ЩО треба ЗМІНИТИ в існуючому?

**ФОРМАТ ВІДПОВІДІ ДЛЯ КОРИСТУВАЧА:**
```
🔍 РЕЗУЛЬТАТИ ПОШУКУ:

Знайдено:
- src/lib/qr-scanner.ts (базова логіка сканування)
- src/types/qr.ts (типи для QR кодів)
- src/components/QRScanner.tsx (UI компонент)

НЕ знайдено:
- API endpoint для сканування
- Інтеграція з backend

📊 АНАЛІЗ:
Існує повна клієнтська імплементація QR-сканування.
Відсутній тільки API endpoint для backend обробки.

💡 РІШЕННЯ: Створити ТІЛЬКИ API endpoint, використовуючи існуючі типи з src/types/qr.ts
```

---

## 🎯 ПРАВИЛА ПРИЙНЯТТЯ РІШЕННЯ

### СЦЕНАРІЙ 1: ІСНУЄ ПОВНА ІМПЛЕМЕНТАЦІЯ

```
✅ ЗНАЙДЕНО: src/lib/qr-scanner.ts з повною логікою сканування

РІШЕННЯ:
❌ НЕ створювати новий функціонал
❌ НЕ дублювати існуючу логіку
✅ Використовувати існуючий функціонал
✅ За потреби - додати недостатні частини ДО ІСНУЮЧОГО
✅ Якщо потрібна зміна - змінювати ІСНУЮЧИЙ код
```

**Приклад:**
```typescript
// ❌ НЕПРАВИЛЬНО - дублювання
// src/api/qr-scanner.ts
export function scanQRCode(image: Buffer) {
  // Реалізація сканування (дублює src/lib/qr-scanner.ts!)
}

// ✅ ПРАВИЛЬНО - використання існуючого
// src/api/qr-scanner.ts
import { scanQRCode } from '@/lib/qr-scanner';

export async function handleQRScan(req, res) {
  const result = await scanQRCode(req.body.image);
  return res.json(result);
}
```

### СЦЕНАРІЙ 2: ІСНУЄ ЧАСТКОВИЙ ФУНДАМЕНТ

```
✅ ЗНАЙДЕНО: src/lib/reports/exporter.ts (експорт в CSV, Excel)

РІШЕННЯ:
❌ НЕ створювати з нуля
❌ НЕ ігнорувати існуючий фундамент
✅ Розширити існуючу імплементацію
✅ Додати ТІЛЬКИ відсутні компоненти
✅ Змінити існуючі частини якщо потрібно
✅ Зберегти сумісність з існуючим кодом
```

**Приклад:**
```typescript
// ❌ НЕПРАВИЛЬНО - створення паралельної системи
// src/lib/pdf-exporter.ts
export class PDFExporter {
  // Нова система експорту (дублює архітектуру exporter.ts!)
}

// ✅ ПРАВИЛЬНО - розширення існуючого
// src/lib/reports/exporter.ts
export class ReportExporter {
  exportToCSV(data: Report) { /* існуюче */ }
  exportToExcel(data: Report) { /* існуюче */ }

  // ДОДАНО: нова функціональність
  exportToPDF(data: Report) {
    // Використовує ту саму архітектуру
    return this.generateReport(data, 'pdf');
  }
}
```

### СЦЕНАРІЙ 3: НІЧОГО НЕ ЗНАЙДЕНО

```
❌ НЕ ЗНАЙДЕНО: жодної імплементації або фундаменту

РІШЕННЯ:
✅ Створити новий функціонал
✅ Слідувати архітектурним патернам проекту
✅ Документувати для майбутніх пошуків
✅ Додати коментарі для Grep пошуку
```

**Приклад:**
```typescript
// ✅ ПРАВИЛЬНО - створення нового з документацією
/**
 * WebSocket Real-time Communication Module
 *
 * @keywords websocket, realtime, socket, communication
 * @architecture event-driven
 * @dependencies socket.io
 */
export class WebSocketManager {
  // Нова імплементація з нуля
}
```

---

## 📋 ОБОВ'ЯЗКОВИЙ ЧЕК-ЛИСТ ПЕРЕД ЗМІНАМИ

**Перед початком реалізації ОБОВ'ЯЗКОВО:**

```
☐ 1. Виконав Grep пошук за ключовими словами
☐ 2. Виконав Glob пошук за патерном файлів
☐ 3. Прочитав ВСІ знайдені файли (Read tool)
☐ 4. Проаналізував знайдені результати
☐ 5. Показав користувачу ПОВНИЙ СПИСОК знайденого
☐ 6. Обґрунтував рішення (створити/розширити/змінити/використати)
☐ 7. Отримав підтвердження користувача перед початком
```

**ФОРМАТ ПІДТВЕРДЖЕННЯ:**
```
🔍 Виконано пошук:
- Grep: знайдено 3 файли
- Glob: знайдено 5 файлів
- Прочитано: всі 8 файлів

📊 Аналіз:
[детальний аналіз існуючого функціоналу]

💡 Рекомендоване рішення: [створити/розширити/змінити/використати]

❓ Чи підтверджуєте цей підхід перед початком реалізації?
```

---

## 🎬 ПРИКЛАДИ ПРАВИЛЬНОГО WORKFLOW

### ПРИКЛАД 1: Створення нового функціоналу

**Задача:** Створити API endpoint для QR-сканування

```
ШАГ 1: ПЕРЕВІРКА
┌─────────────────────────────────────────────┐
│ Grep(pattern="qr.*scan|scan.*qr")          │
│ Glob(pattern="**/qr*.{ts,tsx}")            │
└─────────────────────────────────────────────┘
              ↓
ШАГ 2: АНАЛІЗ РЕЗУЛЬТАТІВ
┌─────────────────────────────────────────────┐
│ Знайдено:                                   │
│ - src/lib/qr-scanner.ts (базова логіка)    │
│ - src/types/qr.ts (типи)                   │
│ - src/components/QRScanner.tsx (UI)        │
│                                             │
│ НЕ знайдено:                                │
│ - API endpoint                              │
└─────────────────────────────────────────────┘
              ↓
ШАГ 3: РІШЕННЯ
┌─────────────────────────────────────────────┐
│ ✅ НЕ створювати qr-scanner.ts (існує)     │
│ ✅ Використати існуючу логіку               │
│ ✅ Створити ТІЛЬКИ API endpoint             │
└─────────────────────────────────────────────┘
              ↓
ШАГ 4: ПОВІДОМЛЕННЯ КОРИСТУВАЧУ
┌─────────────────────────────────────────────┐
│ "🔍 Знайдено існуючий функціонал:          │
│ - src/lib/qr-scanner.ts                     │
│ - src/types/qr.ts                           │
│                                             │
│ 💡 Рішення: Створю API endpoint який        │
│ використовує існуючу логіку.               │
│                                             │
│ Чи підтверджуєте цей підхід?"              │
└─────────────────────────────────────────────┘
              ↓
ШАГ 5: РЕАЛІЗАЦІЯ (після підтвердження)
```

### ПРИКЛАД 2: Зміна існуючого функціоналу

**Задача:** Додати підтримку PDF експорту в систему звітів

```
ШАГ 1: ПЕРЕВІРКА
┌─────────────────────────────────────────────┐
│ Grep(pattern="export|pdf|report")          │
│ Glob(pattern="**/reports/**/*.ts")         │
└─────────────────────────────────────────────┘
              ↓
ШАГ 2: АНАЛІЗ РЕЗУЛЬТАТІВ
┌─────────────────────────────────────────────┐
│ Знайдено:                                   │
│ - src/lib/reports/exporter.ts (CSV, Excel) │
│ - src/lib/reports/generator.ts             │
│ - src/types/reports.ts                     │
└─────────────────────────────────────────────┘
              ↓
ШАГ 3: РІШЕННЯ
┌─────────────────────────────────────────────┐
│ ✅ НЕ створювати новий exporter.ts          │
│ ✅ Розширити ІСНУЮЧИЙ exporter.ts           │
│ ✅ Додати метод exportToPDF()               │
│ ✅ Використати існуючий generator.ts        │
└─────────────────────────────────────────────┘
              ↓
ШАГ 4: ПОВІДОМЛЕННЯ КОРИСТУВАЧУ
┌─────────────────────────────────────────────┐
│ "🔍 Знайдено систему експорту:             │
│ - src/lib/reports/exporter.ts              │
│                                             │
│ 💡 Рішення: Розширю існуючий exporter.ts   │
│ додавши метод exportToPDF().               │
│                                             │
│ Чи підтверджуєте?"                         │
└─────────────────────────────────────────────┘
              ↓
ШАГ 5: РЕАЛІЗАЦІЯ (після підтвердження)
```

### ПРИКЛАД 3: Рефакторинг існуючого коду

**Задача:** Винести загальну логіку валідації в окремий утилітарний файл

```
ШАГ 1: ПЕРЕВІРКА
┌─────────────────────────────────────────────┐
│ Grep(pattern="validate|validation")        │
│ Glob(pattern="**/utils/**/*valid*.ts")     │
└─────────────────────────────────────────────┘
              ↓
ШАГ 2: АНАЛІЗ РЕЗУЛЬТАТІВ
┌─────────────────────────────────────────────┐
│ Знайдено:                                   │
│ - src/utils/validators.ts (існує!)         │
│ - src/components/Form.tsx (дублює)         │
│ - src/api/middleware.ts (дублює)           │
└─────────────────────────────────────────────┘
              ↓
ШАГ 3: РІШЕННЯ
┌─────────────────────────────────────────────┐
│ ✅ НЕ створювати новий validation.ts        │
│ ✅ Розширити validators.ts                  │
│ ✅ Видалити дублікати з Form.tsx            │
│ ✅ Видалити дублікати з middleware.ts       │
│ ✅ Замінити на виклики validators.ts        │
└─────────────────────────────────────────────┘
              ↓
ШАГ 4: ПОВІДОМЛЕННЯ КОРИСТУВАЧУ
┌─────────────────────────────────────────────┐
│ "🔍 Знайдено:                               │
│ - src/utils/validators.ts (вже існує!)     │
│ - Дублікати в Form.tsx та middleware.ts    │
│                                             │
│ 💡 Рішення:                                 │
│ 1. Розширю validators.ts                    │
│ 2. Видалю дублікати                         │
│ 3. Замінювану логіку на виклики             │
│                                             │
│ Чи підтверджуєте?"                         │
└─────────────────────────────────────────────┘
              ↓
ШАГ 5: РЕАЛІЗАЦІЯ (після підтвердження)
```

---

## ❌ ПРИКЛАДИ НЕПРАВИЛЬНОЇ ПОВЕДІНКИ

### ПОМИЛКА 1: Створення без перевірки

```
Задача: Створити API endpoint для QR-сканування

❌ НЕПРАВИЛЬНО:
Agent: "Створюю новий файл src/api/qr-scanner.ts..."

ПРОБЛЕМА:
- ❌ НЕ перевірив чи існує qr-scanner
- ❌ НЕ знайшов src/lib/qr-scanner.ts
- ❌ Створив дублікат функціоналу
- ❌ Тепер 2 різні реалізації QR-сканування в проекті
```

### ПОМИЛКА 2: Зміна без аналізу

```
Задача: Додати PDF експорт

❌ НЕПРАВИЛЬНО:
Agent: "Створюю новий src/lib/pdf-exporter.ts..."

ПРОБЛЕМА:
- ❌ НЕ перевірив чи існує система експорту
- ❌ НЕ розширив існуючий exporter.ts
- ❌ Створив паралельну систему експорту
- ❌ Порушив єдину архітектуру проекту
```

### ПОМИЛКА 3: Рефакторинг без пошуку

```
Задача: Винести валідацію в utils

❌ НЕПРАВИЛЬНО:
Agent: "Створюю src/utils/validation.ts..."

ПРОБЛЕМА:
- ❌ НЕ знайшов існуючий validators.ts
- ❌ Створив ще один файл валідації
- ❌ Тепер 2 файли валідації в utils/
- ❌ Незрозуміло який використовувати
```

---

## 🛡️ МЕХАНІЗМ ЗУПИНКИ ПРИ ПОРУШЕННІ

### Автоматична валідація ПЕРЕД реалізацією:

```python
def before_code_changes():
    """Перевірка перед будь-якими змінами коду."""

    # Checkpoint 1: Чи виконано Grep пошук?
    if not grep_search_performed:
        raise ValidationError("ЗУПИНИТИСЯ! Виконай Grep пошук перед змінами!")

    # Checkpoint 2: Чи виконано Glob пошук?
    if not glob_search_performed:
        raise ValidationError("ЗУПИНИТИСЯ! Виконай Glob пошук перед змінами!")

    # Checkpoint 3: Чи прочитані знайдені файли?
    if found_files and not all_files_read:
        raise ValidationError("ЗУПИНИТИСЯ! Прочитай ВСІ знайдені файли!")

    # Checkpoint 4: Чи показано результати користувачу?
    if not user_informed:
        raise ValidationError("ЗУПИНИТИСЯ! Покажи користувачу результати пошуку!")

    # Checkpoint 5: Чи отримано підтвердження?
    if not user_confirmed:
        raise ValidationError("ЗУПИНИТИСЯ! Отримай підтвердження користувача!")

    return True
```

### Тригери зупинки:

```
ЯКЩО агент:
├─ Починає створювати БЕЗ Grep/Glob → ЗУПИНИТИСЯ, виконати пошук
├─ Не показав список знайденого → ЗУПИНИТИСЯ, показати результати
├─ Створив дублікат існуючого → ЗУПИНИТИСЯ, видалити, використати існуюче
└─ Змінює код БЕЗ аналізу існуючого → ЗУПИНИТИСЯ, проаналізувати спочатку

ЯКЩО користувач виявив дублювання:
└─ Агент ОБОВ'ЯЗКОВО видаляє дублікат та використовує існуюче
```

---

## 📊 МЕТРИКИ УСПІХУ

**Після впровадження протоколу:**

- ✅ 0% дублювання коду (було: 20-30%)
- ✅ 100% перевірок існуючого коду перед створенням/зміною
- ✅ 90%+ правильних рішень (використати/розширити/створити)
- ✅ 100% підтверджень від користувача перед реалізацією
- ✅ 0% паралельних систем для того самого функціоналу

---

## 🔗 ЗВ'ЯЗОК З ІНШИМИ МОДУЛЯМИ

**Цей модуль доповнює:**
- **09a_no_guessing_protocol.md** - заборона вгадування без аналізу
- **09b_problem_context_analysis.md** - аналіз контексту проблем
- **09c_error_escalation_protocol.md** - ескалація помилок

**Використовується в:**
- **02_workflow_rules.md** - загальний workflow
- **01_role_switching.md** - нагадування при переключенні ролі
- **CLAUDE.md** - критичні правила проекту

---

**Версія:** 1.0
**Дата:** 2025-10-13
**Автор:** Archon Blueprint Architect
**Статус:** Активний модуль протоколу аналізу проблем
