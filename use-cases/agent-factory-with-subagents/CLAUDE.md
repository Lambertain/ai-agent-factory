# 🚨 КРИТИЧЕСКИ ВАЖНО: ЧИТАЙ ПРАВИЛА ПЕРЕД РАБОТОЙ!

## ⚠️ ОБЯЗАТЕЛЬНО ПЕРЕД ЛЮБОЙ ЗАДАЧЕЙ:
**ПРОЧИТАЙ `.claude/rules.md` ЭТОГО ПРОЕКТА!**

### 🎭 При получении задачи с assignee:
1. 📋 **СНАЧАЛА** прочитай `.claude/rules.md` текущего проекта
2. 🎭 **ОПРЕДЕЛИ РОЛЬ** агента (pydantic-ai-planner, pydantic-ai-prompt-engineer, etc.)
3. 📖 **НАЙДИ ПРОМПТ** роли через RAG: `mcp__archon__rag_search_knowledge_base`
4. 🔍 **ИЗУЧИ ЭКСПЕРТИЗУ** роли через RAG
5. 🧠 **ПОГРУЗИСЬ В КОНТЕКСТ** эксперта
6. ✅ **ТОЛЬКО ПОТОМ** выполняй задачу в роли эксперта

**НИ ОДНА ЗАДАЧА НЕ ВЫПОЛНЯЕТСЯ БЕЗ ПЕРЕКЛЮЧЕНИЯ В РОЛЬ!**

---

# 🏭 Фабрика агентов Pydantic AI – глобальные правила оркестрации

## 📋 ОБЯЗАТЕЛЬНО К ПРОЧТЕНИЮ ПЕРЕД ЛЮБОЙ РАБОТОЙ

🚨 **КРИТИЧЕСКИ ВАЖНЫЕ ПРАВИЛА**: [.claude/rules.md](.claude/rules.md)

**ПРАВИЛА КАЧЕСТВА:**
1. **ПРОВЕРКА ПЕРЕД СОЗДАНИЕМ** - всегда ищи существующие файлы/задачи
2. **3-ЭТАПНОЕ ВЫПОЛНЕНИЕ** - выполнение → проверка → улучшение
3. **НИКОГДА не завершай задачу без критического анализа и улучшений**

Этот документ описывает полный рабочий цикл системы AI Agent Factory и принципы, которые применяются ко ВСЕЙ разработке агентов на Pydantic AI. Когда пользователь просит создать AI-агента, следуй этой пошаговой схеме с использованием специализированных субагентов, чтобы превратить высокоуровневые требования в простой, но завершённый Pydantic AI‑агент.

**Базовая философия**: «Преврати просьбу вроде "хочу агента, который ищет в интернете" в полностью готовый и протестированный агент на Pydantic AI». Участие пользователя требуется только на этапе уточнения (Фаза 0), затем процесс идёт автономно.

---

## 🌐 КРИТИЧЕСКИ ВАЖНО: ПРИНЦИП УНИВЕРСАЛЬНОСТИ АГЕНТОВ

**ВСЕ АГЕНТЫ ДОЛЖНЫ БЫТЬ УНИВЕРСАЛЬНЫМИ!**

### ❌ ЗАПРЕЩЕНО:
- Жёсткие привязки к конкретным проектам (UniPark, etc.)
- Hardcoded цветовые палитры или брендинг
- Фиксированные схемы данных
- Проект-специфичные промпты
- Неконфигурируемые зависимости
- Упоминания конкретных компаний или продуктов в коде

### ✅ ОБЯЗАТЕЛЬНО:
- Конфигурируемые настройки проекта через environment variables
- Динамические цветовые схемы через настройки
- Адаптивные промпты под различные технологии и домены
- Examples/ папка с конфигурациями для разных доменов (e-commerce, SaaS, CRM, blog, etc.)
- Универсальная документация в README с примерами для разных use cases
- Настраиваемые зависимости через dataclass с полями типа domain_type, project_type
- Поддержка multiple frameworks/technologies в одном агенте

### 🔍 КРИТЕРИИ УНИВЕРСАЛЬНОСТИ:
- Агент работает с любым проектом данного типа (frontend, backend, database, etc.)
- 0% упоминаний конкретных проектов в коде и промптах
- ≥3 примера конфигураций для разных доменов
- Полная адаптируемость через настройки

---

## 📋 ОБЯЗАТЕЛЬНОЕ ПРАВИЛО ДЛЯ КАЖДОЙ ЗАДАЧИ

🚨 **КРИТИЧЕСКИ ВАЖНО**: Перед началом ЛЮБОЙ задачи в Archon:

1. **ВСЕГДА ЧИТАЙ** этот файл CLAUDE.md полностью
2. **ПРИМЕНЯЙ .claude/rules.md**: 3-этапное выполнение (выполнение → проверка → улучшение)
3. **ПРОВЕРЬ СУЩЕСТВОВАНИЕ**: Glob/Read для поиска дубликатов ПЕРЕД созданием
4. **ОБЯЗАТЕЛЬНО ДОБАВЛЯЙ** в описание задачи ссылку:
   ```
   📖 Правила работы: см. /use-cases/agent-factory-with-subagents/CLAUDE.md
   📋 Качество: см. .claude/rules.md
   ```
5. **ПРИМЕНЯЙ РЕФЛЕКСИЮ ДО ЗАВЕРШЕНИЯ**: ПЕРЕД тем как отметить задачу выполненной, критически анализируй результат, выявляй недостатки и улучшай. Только после рефлексии и улучшений отмечай задачу как "done"
6. **СОБЛЮДАЙ ПОСЛЕДОВАТЕЛЬНОСТЬ**: сначала базы знаний, потом агенты
7. **СОЗДАВАЙ БАЗЫ ЗНАНИЙ** сразу в правильную директорию `agents/[agent_name]/knowledge/` чтобы не переносить
8. **ОБНОВЛЯЙ СТАТУС** в Archon в реальном времени

## 🎯 Основная директива

🚨 **КРИТИЧЕСКИЙ ТРИГГЕР**: если в запросе пользователя есть создание / разработка / построение AI‑агента:

1. **НЕМЕДЛЕННО** распознай, что это заказ фабрики агентов (прерви все остальные задачи)
2. **ОБЯЗАТЕЛЬНО** начни с Фазы 0 – задай уточняющие вопросы
3. **ДОЖДИСЬ** ответов пользователя
4. **ЗАТЕМ** проверь Archon и продолжай по рабочему процессу

**Паттерны, по которым фабрика должна включаться (если пользователь говорит что-то из списка):**
- «Собери AI‑агента, который…»
- «Создай агента для…»  
- «Мне нужен ассистент, который умеет…»
- «Сделай агента на Pydantic AI…»
- «Хочу построить агента на Pydantic AI…»
- Любое упоминание agent/AI/LLM + описания функциональности

**ОБЯЗАТЕЛЬНАЯ интеграция с Archon (после завершения Фазы 0):**
1. После получения уточнений пользователя вызови `mcp__archon__health_check`
2. Если Archon доступен:
   - **СОЗДАЙ** проект Archon для строящегося агента
   - **СОЗДАЙ** в Archon задачи для каждой фазы пайплайна:
     - Задача 1: «Requirements Analysis» (Фаза 1 – pydantic-ai-planner)
     - Задача 2: «System Prompt Design» (Фаза 2A – pydantic-ai-prompt-engineer)
     - Задача 3: «Tool Development Planning» (Фаза 2B – pydantic-ai-tool-integrator)
     - Задача 4: «Dependency Configuration» (Фаза 2C – pydantic-ai-dependency-manager)
     - Задача 5: «Agent Implementation» (Фаза 3 – основной Claude Code)
     - Задача 6: «Validation & Testing» (Фаза 4 – pydantic-ai-validator)
     - Задача 7: «Documentation & Delivery» (Фаза 5 – основной Claude Code)
   - **ОБНОВЛЯЙ** статус каждой задачи по мере продвижения:
     - ставь «doing», когда фаза стартует
     - ставь «done», когда фаза завершена успешно
     - добавляй заметки о проблемах или отклонениях
   - **ИСПОЛЬЗУЙ** RAG Archon во время реализации для поиска документации
   - **ПЕРЕДАЙ** всем субагентам идентификатор проекта Archon
3. Если Archon недоступен: прерывай работу и сообщай пользователю

**ДИСЦИПЛИНА РАБОТОПРОЦЕССА:**
1. Всегда начинай с Фазы 0 (уточняющие вопросы)
2. Жди ответа пользователя, прежде чем двигаться дальше
3. Проходи ВСЕ фазы строго по порядку
4. Никогда не переходи сразу к реализации

Когда требуется привлечь субагента, обязательно вызови его, сформулировав промпт и передав ему управление.

---

## 🎯 КРИТИЧЕСКИ ВАЖНО: Управление задачами ТОЛЬКО через Archon

**🚨 ЗАПРЕЩЕНО использовать TodoWrite или любые локальные системы задач!**

### Правила создания задач в Archon:

1. **ДЛЯ ЛЮБОЙ РАБОТЫ** - создавай задачи в Archon:
   - Создание агентов
   - Исправление багов
   - Добавление функций
   - Настройка RAG
   - Любые запросы пользователя

2. **АЛГОРИТМ создания задач:**
   ```
   ЭТАП 1: Создать ОБЩУЮ задачу
   - Название: краткое описание работы
   - Описание: детали того, что нужно сделать
   - Assignee: "Archon Analysis Lead" (для анализа и декомпозиции)
   - Status: "todo"

   ЭТАП 2: Analysis Lead разбивает на микрозадачи
   - Анализирует общую задачу
   - Создает конкретные подзадачи
   - Назначает исполнителей: Implementation Engineer, Quality Guardian и т.д.
   - Ставит зависимости между задачами

   ЭТАП 3: Исполнители работают над подзадачами
   - Обновляют статусы: todo → doing → review → done
   - Добавляют комментарии о прогрессе
   - Создают дополнительные задачи при необходимости
   ```

3. **ОБЯЗАТЕЛЬНЫЕ поля при создании задач:**
   - `title`: на русском языке, краткое описание
   - `description`: подробное описание на русском
   - `assignee`: правильный субагент согласно специализации
   - `project_id`: "c75ef8e3-6f4d-4da2-9e81-8d38d04a341a" (AI Agent Factory)

4. **Назначение субагентов:**
   - **Archon Analysis Lead**: анализ, планирование, декомпозиция
   - **Archon Implementation Engineer**: код, реализация функций
   - **Archon Quality Guardian**: тестирование, проверка качества
   - **Archon Blueprint Architect**: архитектура, дизайн систем

5. **ВАЖНО: Ты сам являешься всеми субагентами!**
   - Когда создаешь задачу с assignee "Archon Analysis Lead" - переключайся в роль аналитика
   - Когда задача назначена "Implementation Engineer" - работаешь как программист
   - Каждая роль имеет свою экспертизу, но это всё ты с разным контекстом
   - **После создания задачи СРАЗУ приступай к выполнению в нужной роли**

6. **МУЛЬТИАГЕНТНЫЕ ПАТТЕРНЫ** (по Эндрю Ыну - 4 ключевых паттерна):

   ### 🤝 **0. COLLECTIVE PROBLEM SOLVING (Коллективное решение задач) - НОВЫЙ ПАТТЕРН**
   - **АВТОМАТИЧЕСКАЯ ДЕКОМПОЗИЦИЯ**: Каждый агент должен автоматически определять, требует ли задача привлечения других агентов
   - **МИКРОЗАДАЧИ В ЧАТ**: Перед началом работы агент ОБЯЗАН:
     1. Разбить задачу на 3-7 микрозадач
     2. Вывести список микрозадач пользователю в чате
     3. Отчитываться о прогрессе выполнения каждой микрозадачи
   - **МЕЖАГЕНТНОЕ ВЗАИМОДЕЙСТВИЕ**: При обнаружении задач вне компетенции немедленно делегировать через Archon
   - **ОРКЕСТРАЦИЯ**: Координировать работу между агентами для достижения качественного результата

   ### 🔄 **1. REFLECTION (Рефлексия) - ОБЯЗАТЕЛЬНО УСИЛЕННАЯ**
   - **ПЕРЕД ЗАКРЫТИЕМ КАЖДОЙ ЗАДАЧИ** выполняй расширенный цикл рефлексии:
     1. Критический анализ выполненной работы
     2. Выявление минимум 2-3 конкретных недостатков
     3. Создание улучшенной версии результата
     4. Проверка соответствия всем критериям качества
     5. **ТОЛЬКО ПОСЛЕ УЛУЧШЕНИЙ** отмечать задачу как выполненную
   - **НИ ОДНА ЗАДАЧА НЕ ЗАВЕРШАЕТСЯ БЕЗ ПОЛНОГО ЦИКЛА РЕФЛЕКСИИ И УЛУЧШЕНИЙ**
   - **РЕФЛЕКСИЯ ДОЛЖНА БЫТЬ ВИДИМОЙ**: обязательно описывать найденные проблемы и внесенные улучшения

   ### 🛠️ **2. TOOL USE (Использование инструментов)**
   - Каждый агент должен уметь решать, когда использовать инструменты
   - Активно использовать RAG, веб-поиск, выполнение кода
   - Принимать решения о вызове API на основе контекста задачи

   ### 📋 **3. PLANNING (Планирование)**
   - Разбивать сложные задачи на последовательность действий
   - Создавать план выполнения перед началом работы
   - Адаптировать план по ходу выполнения

   ### 👥 **4. MULTI-AGENT COLLABORATION (Мультиагентное сотрудничество)**
   - Агенты специализируются на разных аспектах одной задачи
   - Передача результатов между агентами для улучшения
   - Итеративное взаимодействие: Analysis → Implementation → Quality → Architecture

   ### **ОБНОВЛЕННЫЙ ФОРМАТ ЗАДАЧИ С МУЛЬТИАГЕНТНЫМИ ПАТТЕРНАМИ:**
   ```
   ## 📋 МИКРОЗАДАЧИ (ОБЯЗАТЕЛЬНО В ЧАТ)
   Перед началом работы агент ДОЛЖЕН вывести пользователю:

   📋 **Микрозадачи для выполнения:**
   1. [Конкретная микрозадача 1]
   2. [Конкретная микрозадача 2]
   3. [Конкретная микрозадача 3]
   4. [Конкретная микрозадача 4-7]

   ✅ Буду отчитываться о прогрессе каждой микрозадачи

   ## 🤝 КОЛЛЕКТИВНОЕ ПЛАНИРОВАНИЕ
   1. Анализ сложности задачи и необходимости привлечения других агентов
   2. Определение инструментов и технологий
   3. План межагентного взаимодействия (если нужно)
   4. Создание задач делегирования через Archon

   ## 🛠️ ВЫПОЛНЕНИЕ С ОТЧЕТНОСТЬЮ
   ✅ [Микрозадача 1] - выполнена
   - Использование RAG для поиска знаний
   - Применение специализированных инструментов
   - Принятие решений о делегировании

   ✅ [Микрозадача 2] - выполнена
   - [Описание выполненных действий]

   ## 🔄 РАСШИРЕННАЯ РЕФЛЕКСИЯ (ОБЯЗАТЕЛЬНО)
   ### 🔍 Критический анализ выполненной работы:
   1. **Найденные недостатки:**
      - [Конкретный недостаток 1]
      - [Конкретный недостаток 2]
      - [Конкретный недостаток 3]

   2. **Внесенные улучшения:**
      - [Конкретное улучшение 1]
      - [Конкретное улучшение 2]
      - [Конкретное улучшение 3]

   3. **Проверка критериев качества:**
      - ✅ Универсальность (0% проект-специфичного кода)
      - ✅ Модульность (файлы до 500 строк)
      - ✅ Документация и примеры
      - ✅ Тестирование

   ### 🎯 ФИНАЛЬНАЯ ВЕРСИЯ (только после улучшений)
   [Описание итогового улучшенного результата]

   ### 👥 ПЕРЕДАЧА СЛЕДУЮЩЕМУ АГЕНТУ (если нужно)
   [Создание задачи в Archon для следующего этапа]
   ```

7. **MCP СЕРВЕРЫ - РАСШИРЕНИЕ ВОЗМОЖНОСТЕЙ**:

   ### 🔌 **Проактивная рекомендация MCP серверов**

   **СНАЧАЛА ПРОВЕРЬ**, какие MCP серверы уже установлены:
   ```
   C:\Users\Admin\AppData\Roaming\Claude\claude_desktop_config.json
   ```

   **Также проверь доступные MCP через ListMcpResourcesTool (если доступен)**

   Если для задачи нужны дополнительные возможности, **ПРЕДЛАГАЙ установить соответствующие MCP серверы**:

   **Рекомендуемые MCP серверы для разработки:**
   - **context7** - управление контекстом и долговременной памятью (критически важен для больших проектов)
   - **brave-search** - поиск документации и примеров кода в интернете
   - **postgres** - прямая работа с базой данных для Prisma агента
   - **gitlab/github** - интеграция с системами контроля версий
   - **slack** - коммуникация и уведомления команды

   **Формат предложения:**
   ```
   💡 Рекомендация: Для эффективной работы с [задача] рекомендую установить MCP сервер [название].

   Преимущества:
   - [преимущество 1]
   - [преимущество 2]

   Установка: npx @modelcontextprotocol/create-server [название]

   Документация MCP: https://docs.claude.com/en/docs/claude-code/mcp
   ```

   **Особенно важно:**
   - **Context7** для управления большими кодовыми базами и сохранения контекста между сессиями
   - **Database MCP** для прямой работы с PostgreSQL при разработке Prisma агента
   - **Search MCP** для поиска актуальной документации и best practices

8. **НИКОГДА НЕ ИСПОЛЬЗУЙ:**
   - `TodoWrite`
   - Локальные списки задач
   - Любые другие системы кроме Archon

---

## 🔁 Полный рабочий цикл фабрики

### Фаза 0. Распознавание запроса и уточнение требований
**Срабатывает**, если услышано что-то из списка выше.

**Первые действия:**
```
1. Подтверди пользователю, что начинаешь создание агента
2. Задай 2–3 уточняющих вопроса (ДО запуска планировщика):
   - Какую основную задачу решает агент, в каком сценарии используется?
   - Есть ли предпочтительные API или интеграции (если актуально)?
   - В каком формате ожидать ответы / результат?
3. 🚨 СУПЕРВАЖНО: ОСТАНОВИСЬ и ЖДИ ответов пользователя
   - не переходи к шагу 4, пока не получишь ответы
   - не делай предположений «ради скорости»
   - не создавай директории и не вызывай субагентов заранее
   - продолжай только после явного ответа пользователя
4. После того как ответы получены: ОПРЕДЕЛИ имя папки агента (snake_case, например `web_search_agent`, `asana_manager`)
5. Создай директорию `agents/[ИМЯ_ПАПКИ]/`
6. Запусти ВСЕХ субагентов, передав им ТО ЖЕ имя папки
7. Сообщи каждому субагенту: «Сохраняй результат в agents/[ИМЯ_ПАПКИ]/»
```

### Фаза 1. Документирование требований 🗂️
**Субагент**: `pydantic-ai-planner`
**Когда**: сразу после завершения Фазы 0
**Режим**: АВТОНОМНЫЙ – не спрашивает пользователя
**Принцип**: Простой список требований, ориентация на MVP
**Archon**: перед запуском субагента переведи Задачу 1 в статус «doing»

```
Алгоритм:
1. В Archon поставить задачу «Requirements Analysis» в состояние «doing»
2. Получить от основного агента запрос, ответы пользователя, имя папки и ID проекта Archon
3. Сконцентрироваться на КЛЮЧЕВОЙ функциональности (1–2 основных сценария)
4. Сделать простые и прагматичные допущения (один провайдер модели, базовая обработка ошибок)
5. Сформировать минималистичный INITIAL.md с максимум 2–3 ключевыми возможностями
6. Сохранить файл: `agents/[ТОЧНО_ИМЯ]/planning/INITIAL.md`
   🚨 ОБЯЗАТЕЛЬНО клади файл в подпапку `planning/`
7. После завершения пометить задачу Archon как «done»
```

**КРИТИЧЕСКАЯ ПРОВЕРКА УНИВЕРСАЛЬНОСТИ:**
- ✅ Агент должен работать с любым проектом данного типа
- ✅ 0% упоминаний конкретных проектов в требованиях
- ✅ Конфигурируемые настройки для разных доменов
- ✅ Адаптивные паттерны под различные технологии
- ✅ Примеры для ≥3 различных use cases

**Контроль качества:** INITIAL.md обязан содержать:
- ✅ Классификацию и тип агента (универсального)
- ✅ Функциональные требования (адаптируемые)
- ✅ Технические требования (конфигурируемые)
- ✅ Внешние зависимости (настраиваемые)
- ✅ Критерии успеха (универсальности)

### Фаза 2. Параллельная разработка компонентов ⚙️
**Все три субагента работают ОДНОВРЕМЕННО**
**Archon**: перед параллельным запуском переведи Задачи 2, 3, 4 в статус «doing»

**КРИТИЧЕСКОЕ требование:** вызывай все три таска одним сообщением с несколькими вызовами инструмента `Task`. Так обеспечивается реальный параллелизм.
- 🚫 НЕЛЬЗЯ: сначала вызывать планировщика, ждать завершения, затем промпт-инженера
- ✅ НАДО: одним сообщением запустить три `Task` для Prompt Engineer, Tool Integrator, Dependency Manager
- Сразу пометь все три задачи Archon (2, 3, 4) статусом «doing»

#### 2A. Проектирование системного промпта
**Субагент**: `pydantic-ai-prompt-engineer`
**Принцип**: краткие и понятные промпты (100–300 слов)
```
Вход: planning/INITIAL.md + имя папки
Выход: `agents/[ТОЧНО_ИМЯ]/planning/prompts.md`
🚨 Сохраняй MARKDOWN с описанием промпта, НЕ Python‑код
Содержание:
- один статичный системный промпт (100–300 слов)
- никаких динамических промптов без крайней необходимости
- только ключевое поведение
```

#### 2B. Планирование инструментов
**Субагент**: `pydantic-ai-tool-integrator`
**Принцип**: минимум инструментов (2–3 функции)
```
Вход: planning/INITIAL.md + имя папки
Выход: `agents/[ТОЧНО_ИМЯ]/planning/tools.md`
🚨 MARKDOWN со спецификацией инструментов, НЕ Python‑код
Содержание:
- 2–3 обязательных инструмента
- простые параметры (1–3 на инструмент)
- базовая обработка ошибок
- инструменты должны выполнять одну чёткую задачу
```

#### 2C. Планирование конфигурации зависимостей
**Субагент**: `pydantic-ai-dependency-manager`
**Принцип**: только необходимые переменные окружения и зависимости
```
Вход: planning/INITIAL.md + имя папки
Выход: `agents/[ТОЧНО_ИМЯ]/planning/dependencies.md`
🚨 MARKDOWN с описанием зависимостей, НЕ Python‑код
Содержание:
- только обязательные переменные окружения
- один провайдер модели (без баккапов)
- простые dataclass‑зависимости
- минимум внешних пакетов
```

**Фаза 2 считается выполненной**, когда все три субагента завершили работу и вернули файлы.

### Фаза 3. Реализация агента 💻
**Исполнитель**: основной Claude Code (без субагентов)
**Archon**: перед началом переведи Задачу 5 в «doing»

```
Шаги:
1. В Archon для «Agent Implementation» выставить статус «doing»
2. Убедиться, что задачи 2, 3, 4 завершены (обновить на «done»)
3. Прочитать 4 файла планирования:
   - agents/[папка]/planning/INITIAL.md
   - agents/[папка]/planning/prompts.md
   - agents/[папка]/planning/tools.md
   - agents/[папка]/planning/dependencies.md
4. Использовать Archon RAG для поиска шаблонов и примеров Pydantic AI
5. Написать Python‑код по спецификациям С ОБЯЗАТЕЛЬНОЙ УНИВЕРСАЛЬНОСТЬЮ:
   - перенести промпты → `prompts.py` (адаптивные под домены)
   - инструменты → `tools.py` (конфигурируемые)
   - зависимости → `settings.py`, `providers.py`, `dependencies.py` (с полями domain_type, project_type)
6. Собрать полный агент:
   - объединить компоненты в `agent.py`
   - связать зависимости и инструменты
   - добавить точку входа/CLI при необходимости
7. По завершении пометить задачу 5 как «done»
8. Итоговая структура (УНИВЕРСАЛЬНОГО АГЕНТА):
   agents/[agent_name]/
   ├── agent.py            # основной агент
   ├── settings.py         # конфигурация
   ├── providers.py        # провайдеры моделей
   ├── dependencies.py     # зависимости (с RAG + domain_type, project_type)
   ├── tools.py            # инструменты (включая search_agent_knowledge)
   ├── prompts.py          # системные промпты (адаптивные)
   ├── examples/           # 🌐 ОБЯЗАТЕЛЬНЫЕ ПРИМЕРЫ КОНФИГУРАЦИЙ
   │   ├── ecommerce_config.py     # для e-commerce проектов
   │   ├── saas_config.py          # для SaaS проектов
   │   ├── blog_config.py          # для blog/CMS проектов
   │   └── crm_config.py           # для CRM проектов
   ├── knowledge/          # 📚 ПАПКА ЗНАНИЙ АГЕНТА
   │   └── [agent_name]_knowledge.md  # база знаний для Archon
   ├── __init__.py         # пакет
   ├── requirements.txt    # зависимости Python
   └── .env.example        # шаблон переменных
```

### Фаза 4. Валидация и тесты ✅
**Субагент**: `pydantic-ai-validator`
**Запуск**: автоматически после реализации
**Длительность**: 3–5 минут
**Archon**: перед запуском задачи поставь статус «doing» для Задачи 6

```
Шаги:
1. В Archon перевести «Validation & Testing» в «doing»
2. Вызвать валидатора с именем папки и ID проекта Archon
3. Сгенерировать полный набор тестов
4. Проверить соответствие требованиям из INITIAL.md
5. Прогнать тесты через TestModel
6. Сформировать отчёт о проверке
7. После завершения пометить задачу 6 как «done»
8. Результат: агенты/[имя]/tests/
   ├── test_agent.py
   ├── test_tools.py
   ├── test_integration.py
   ├── test_validation.py
   ├── conftest.py
   └── VALIDATION_REPORT.md
```

**Критерии успеха:**
- все требования покрыты тестами
- основная функциональность проверена
- обработка ошибок протестирована
- производительность удовлетворительная

**🌐 КРИТЕРИИ УНИВЕРСАЛЬНОСТИ (ОБЯЗАТЕЛЬНО):**
- ✅ 0% упоминаний конкретных проектов в коде
- ✅ Конфигурируемые настройки работают
- ✅ ≥3 примера конфигураций протестированы
- ✅ Агент адаптируется под разные домены
- ✅ Адаптивные промпты функционируют корректно

### Фаза 5. Доставка и документация 📦
**Исполнитель**: основной Claude Code
**Archon**: перед началом переведи Задачу 7 в «doing»

```
Финальные шаги:
1. В Archon отметить «Documentation & Delivery» как «doing»
2. Сгенерировать подробный README.md
3. Добавить примеры использования
4. Описать API (если есть)
5. Подготовить инструкции по деплою
6. Пометить задачу 7 как «done»
7. Добавить в проект Archon заключительную заметку о возможностях агента
8. Отправить пользователю итоговый отчёт со ссылкой на проект Archon:
   **ОБЯЗАТЕЛЬНЫЙ ФОРМАТ ОТЧЕТА:**
   ```
   📚 Файлы знаний созданы:

   1. [agent_name]_knowledge.md
      Теги: [agent-name], agent-knowledge, pydantic-ai, [domain-specific-tags]

   Загрузите файлы в Archon Knowledge Base (http://localhost:3737/)

   🎯 Агент готов к использованию:
   - [основная функциональность]
   - [ключевые возможности]

   📁 Структура: agents/[agent_name]/
   📖 Документация: README.md
   🔗 Archon Project: [project-link]
   ```
```

---

## 📋 Протокол управления задачами в Archon

### Создание задач
Если Archon доступен, создавай весь список задач сразу после появления проекта:
```python
# После создания проекта Archon
tasks = [
    {"title": "Requirements Analysis", "assignee": "pydantic-ai-planner"},
    {"title": "System Prompt Design", "assignee": "pydantic-ai-prompt-engineer"},
    {"title": "Tool Development Planning", "assignee": "pydantic-ai-tool-integrator"},
    {"title": "Dependency Configuration", "assignee": "pydantic-ai-dependency-manager"},
    {"title": "Agent Implementation", "assignee": "Claude Code"},
    {"title": "Validation & Testing", "assignee": "pydantic-ai-validator"},
    {"title": "Documentation & Delivery", "assignee": "Claude Code"}
]
# Все задачи создаются со статусом "todo"
```

### Обновление статусов
- Переводи задачу в «doing» прямо перед началом фазы
- Ставь «done» сразу после успешного завершения
- Вноси заметки, если есть проблемы или отклонения
- Никогда не держи несколько задач в статусе «doing» одновременно (исключение – параллельная Фаза 2)

### Коммуникация с субагентами
Всегда передавай субагентам ID проекта Archon:
- добавляй в промпт: «Используй Archon Project ID: [project-id]»
- субагенты должны ссылаться на ID в выходных данных

## 🤖 Правила вызова субагентов

### Автоматический вызов
Субагенты стартуют АВТОМАТИЧЕСКИ по фазам:
```python
if user_request.contains(agent_creation_pattern):
    # Фаза 0 – основной Claude Code уточняет запрос
    clarifications = ask_user_questions()
    
    # Фаза 1 – вызов планировщика
    invoke("pydantic-ai-planner", context={
        "user_request": original_request,
        "clarifications": clarifications
    })
    
    # Фаза 2 – параллельный запуск
    parallel_invoke([
        "pydantic-ai-prompt-engineer",
        "pydantic-ai-tool-integrator", 
        "pydantic-ai-dependency-manager"
    ])
    
    # Фаза 3 – реализация основным агентом
    implement_agent()
    
    # Фаза 4 – автозапуск валидатора
    invoke("pydantic-ai-validator")
```

### Ручной вызов
Пользователь может явно запросить отдельного субагента:
- «Подключи планировщика для уточнения требований»
- «Пусть интегратор инструментов добавит веб-поиск»
- «Запусти валидатор ещё раз»

---

## 📁 Структура выходной директории

Каждый прогон фабрики создаёт:
```
agents/
└── [agent_name]/
    ├── planning/               # все планирующие документы
    │   ├── INITIAL.md          # требования (planner)
    │   ├── prompts.md          # промпты (prompt-engineer)
    │   ├── tools.md            # инструменты (tool-integrator)
    │   └── dependencies.md     # зависимости (dependency-manager)
    ├── agent.py                # реализация агента
    ├── settings.py             # конфигурация
    ├── providers.py            # провайдеры моделей
    ├── dependencies.py         # зависимости
    ├── tools.py                # инструменты
    ├── prompts.py              # промпты
    ├── requirements.txt        # списки пакетов
    ├── .env.example            # пример переменных
    ├── README.md               # документация
    └── tests/                  # тесты и отчёты
```

---

## 🧠 Интеграция с Knowledge Base и RAG

### 📚 Правила создания агентов с базой знаний

**КРИТИЧЕСКИ ВАЖНО**: Каждый специализированный агент ДОЛЖЕН иметь собственную базу знаний в Archon Knowledge Base.

#### Процесс создания агента с знаниями:

1. **СНАЧАЛА** - проверить RAG на наличие знаний:
   ```
   mcp__archon__rag_search_knowledge_base(query="[agent_name] knowledge", match_count=3)
   ```

   **ОБЯЗАТЕЛЬНО**: Перед созданием новых файлов знаний проверьте, нет ли уже этих знаний в RAG!

   **ВАЖНАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ**: При создании специализированных агентов:
   - Сначала создавай ВСЕ файлы знаний для всех агентов проекта
   - Затем создавай самих агентов (agent.py, tools.py и т.д.)
   - Агенты должны ссылаться на уже существующие базы знаний
   - Можно создавать несколько файлов знаний за один раз для группы агентов

2. **ЗАТЕМ** - создать файл знаний сразу в правильном месте (если не найден в RAG):
   ```
   agents/[agent_name]/knowledge/[agent_name]_knowledge.md
   ```

   **ВАЖНО**: Создавайте файл знаний СРАЗУ в папке агента, чтобы не перемещать потом!

3. **ПРЕДОСТАВИТЬ ИНФОРМАЦИЮ ПОЛЬЗОВАТЕЛЮ**:
   После создания файлов знаний ОБЯЗАТЕЛЬНО предоставляй пользователю:
   - **Имена файлов** для загрузки
   - **Рекомендуемые теги** для Knowledge Base

   Формат:
   ```
   📚 Файлы знаний созданы:

   1. [agent_name]_knowledge.md
      Теги: [agent_name], agent-knowledge, pydantic-ai, [domain]

   Загрузите файлы в Archon Knowledge Base (http://localhost:3737/)
   ```

4. **ЗАТЕМ** - загрузить в Archon Knowledge Base:
   - Откройте Archon: **http://localhost:3737/**
   - Knowledge Base → **Upload**
   - Загрузите файл `[agent_name]_knowledge.md`
   - Добавьте теги: `[agent_name]`, `agent-knowledge`, `pydantic-ai`, `[domain]`

5. **ПРИВЯЗАТЬ** к проекту AI Agent Factory:
   - Проект **AI Agent Factory** → вкладка **Sources**
   - **Link Knowledge** → выберите загруженный документ
   - Добавьте описание: "Knowledge base for [Agent Name]"

6. **В КОДЕ АГЕНТА** - обязательно указать путь к знаниям:
   ```python
   # В tools.py или dependencies.py
   KNOWLEDGE_SOURCE_TAGS = ["nextjs", "optimization", "agent-knowledge"]
   KNOWLEDGE_DOMAIN = "docs.nextjs.org"  # если есть

   @agent.tool
   async def search_knowledge_base(
       ctx: RunContext[AgentDependencies],
       query: str
   ) -> str:
       """Поиск в базе знаний агента через Archon RAG."""
       try:
           # Используем MCP Archon для поиска
           result = await mcp_archon_rag_search_knowledge_base(
               query=query,
               source_domain=KNOWLEDGE_DOMAIN,  # опционально
               match_count=5
           )
           return result["results"]
       except Exception as e:
           return f"Ошибка поиска в базе знаний: {e}"
   ```

#### Структура файла знаний:

```markdown
# [Agent Name] Knowledge Base

## Системный промпт
[Детальное описание экспертизы агента]

## Ключевые паттерны
[Примеры кода, конфигураций, best practices]

## Инструменты и методы
[Описание доступных инструментов]

## Специфичные для домена знания
[Примеры для конкретной области: Next.js, Security, UI/UX и т.д.]

## Интеграция с проектами
[Как агент работает с конкретными проектами]
```

#### Обязательные теги для Knowledge Base:
- `[agent_name]` - имя агента (например: `nextjs-optimization`)
- `agent-knowledge` - маркер знаний агента
- `pydantic-ai` - фреймворк
- `[domain]` - область экспертизы (например: `frontend`, `security`, `performance`)

### 🔍 Использование RAG в агентах

**КАЖДЫЙ агент ДОЛЖЕН иметь инструмент поиска в своей базе знаний:**

```python
from pydantic_ai import RunContext

@agent.tool
async def search_agent_knowledge(
    ctx: RunContext[AgentDependencies],
    query: str,
    match_count: int = 5
) -> str:
    """
    Поиск в специализированной базе знаний агента.

    Args:
        query: Поисковый запрос
        match_count: Количество результатов

    Returns:
        Найденная информация из базы знаний
    """
    # Используем теги для фильтрации по знаниям агента
    search_tags = getattr(ctx.deps, 'knowledge_tags', [])

    try:
        result = await mcp_archon_rag_search_knowledge_base(
            query=f"{query} {' '.join(search_tags)}",
            match_count=match_count
        )

        if result["success"] and result["results"]:
            knowledge = "\n".join([
                f"**{r['metadata']['title']}:**\n{r['content']}"
                for r in result["results"]
            ])
            return f"База знаний:\n{knowledge}"
        else:
            # 🚨 ЗАЩИТА: Проверяем есть ли файл знаний в RAG
            agent_name = getattr(ctx.deps, 'agent_name', 'unknown_agent')

            # Попробуем более точный поиск по agent_name
            try:
                fallback_result = await mcp_archon_rag_search_knowledge_base(
                    query=f"{agent_name.replace('_', ' ')} knowledge base",
                    match_count=1
                )

                if fallback_result["success"] and fallback_result["results"]:
                    knowledge = "\n".join([
                        f"**{r['metadata']['title']}:**\n{r['content']}"
                        for r in fallback_result["results"]
                    ])
                    return f"База знаний (найдено через fallback поиск):\n{knowledge}"

            except Exception:
                pass

            # Если и fallback не сработал - предупреждение о проблемах поиска
            warning_message = f"""
⚠️ **ПРОБЛЕМА С ПОИСКОМ В БАЗЕ ЗНАНИЙ**

🔍 **Агент:** {agent_name}
📋 **Поисковые теги:** {', '.join(search_tags) if search_tags else 'не указаны'}
🎯 **Запрос:** {query}

🤔 **ВОЗМОЖНЫЕ ПРИЧИНЫ:**
1. **Векторный поиск работает нестабильно** - попробуйте более специфичные термины
2. **Файл знаний загружен, но не индексирован** - нужно время на индексацию
3. **Проблема с embedding моделью** - низкий similarity score

🛠️ **ПОПРОБУЙТЕ:**
1. Использовать уникальные термины из вашей области экспертизы
2. Поискать по названию файла знаний: `{agent_name}_knowledge`
3. Проверить доступные источники: `mcp__archon__rag_get_available_sources`

💡 **ВАЖНО:** Большинство файлов знаний загружены в Archon, но поиск может работать нестабильно.
Попробуйте переформулировать запрос или использовать более специфичные термины.
"""
            return warning_message

    except Exception as e:
        return f"Ошибка доступа к базе знаний: {e}"
```

### 🎯 Dependency injection для RAG

```python
@dataclass
class AgentDependencies:
    """Зависимости агента с поддержкой RAG."""

    # Основные настройки
    api_key: str
    project_path: str = ""

    # 🚨 ОБЯЗАТЕЛЬНОЕ ПОЛЕ для защиты от отсутствия знаний в RAG
    agent_name: str = ""

    # RAG конфигурация
    knowledge_tags: List[str] = field(default_factory=lambda: [])
    knowledge_domain: str | None = None
    archon_project_id: str | None = None

    def __post_init__(self):
        """Инициализация конфигурации RAG."""
        # Автоопределение имени агента если не указано
        if not self.agent_name:
            # Пытаемся извлечь из пути модуля
            module_parts = self.__class__.__module__.split('.')
            if 'agents' in module_parts:
                agent_index = module_parts.index('agents')
                if agent_index + 1 < len(module_parts):
                    self.agent_name = module_parts[agent_index + 1]

        if not self.knowledge_tags:
            # Устанавливаем теги по умолчанию для агента
            agent_base_name = self.agent_name.replace('_agent', '') if self.agent_name else 'unknown'
            self.knowledge_tags = [agent_base_name, "agent-knowledge", "pydantic-ai"]
```

### 📋 Checklist создания агента с RAG:

- [ ] Создан файл знаний `knowledge/[agent_name]_knowledge.md`
- [ ] Файл загружен в Archon Knowledge Base (http://localhost:3737/)
- [ ] Добавлены правильные теги в Knowledge Base
- [ ] Знания привязаны к проекту AI Agent Factory → Sources
- [ ] В `dependencies.py` указаны `agent_name`, `knowledge_tags` и `knowledge_domain`
- [ ] Добавлен инструмент `search_agent_knowledge` в `tools.py`
- [ ] 🚨 **ОБЯЗАТЕЛЬНО**: Агент тестирует поиск в своей базе знаний при первом запуске
- [ ] В README агента указан путь к базе знаний

### 🛡️ АВТОМАТИЧЕСКАЯ ЗАЩИТА И FALLBACK ПОИСК:

**КАЖДЫЙ АГЕНТ АВТОМАТИЧЕСКИ:**
1. **Ищет свои знания** через стандартный RAG поиск
2. **При неудаче использует fallback поиск** с альтернативными запросами
3. **Диагностирует проблемы поиска** и предлагает конкретные решения
4. **Предоставляет рекомендации** по улучшению поисковых запросов
5. **Информирует о состоянии системы** вместо паники об отсутствии файлов

**Система защиты учитывает:**
- ✅ Файлы знаний загружены в Archon (все файлы есть в системе)
- ⚠️ Векторный поиск может работать нестабильно
- 🔄 Fallback стратегии для поиска знаний
- 💡 Практические советы по улучшению поиска

Эта защита обеспечивает работоспособность агентов даже при проблемах с поисковым алгоритмом.

### Пул знаний Archon
- Ищи актуальные документы в проекте Archon перед началом реализации
- Сохраняй найденные ссылки в задачах Archon
- При необходимости запускай RAG-запросы прямо из реализации
- **ВСЕГДА используй теги для фильтрации знаний по агенту**

### Сторонние источники
- Если Archon недоступен, прерывай работу и сообщай пользователю
- Для внешних источников знаний (GitHub, Notion и т.д.) сохраняй ссылки в README
- Документируй все внешние источники в файле знаний агента

---

## 📚 Использование RAG и пайплайна документов

- Перед началом реализации уточни, нужно ли наполнять базу знаний
- Если да – создай отдельную задачу «Knowledge Base Ingestion» и опиши прогресс
- Субагенты могут обращаться к знаниям через Archon RAG без дополнительных инструкций

---

## 🪜 Стандарты проектирования промптов

**🌐 УНИВЕРСАЛЬНОСТЬ ПРОМПТОВ (ОБЯЗАТЕЛЬНО):**
- ❌ Никаких упоминаний конкретных проектов, компаний или продуктов
- ✅ Адаптивные промпты с переменными для domain_type, project_type
- ✅ Общие архитектурные паттерны, применимые к любому проекту типа
- ✅ Конфигурируемые части промпта через dependencies

**ОБЩИЕ ПРИНЦИПЫ:**
- Промпты должны быть короткими, специфичными и ориентированными на действие
- Избегай дублирования требований – всё должно ссылаться на INITIAL.md
- Не используй «магические» правила; всегда объясняй, почему инструкция важна
- Поддерживай версию промптов в README, чтобы пользователю было понятно, как адаптировать агента

## 🧩 Стандарты архитектуры агентов

**🌐 УНИВЕРСАЛЬНАЯ АРХИТЕКТУРА (ОБЯЗАТЕЛЬНО):**
- ✅ Dependencies с полями domain_type, project_type, framework
- ✅ Примеры конфигураций в examples/ для разных доменов
- ✅ Адаптивные настройки через environment variables
- ✅ Поддержка multiple технологий в одном агенте
- ❌ Никаких hardcoded значений, схем, цветов

**🤝 КОЛЛЕКТИВНАЯ АРХИТЕКТУРА (НОВЫЕ ТРЕБОВАНИЯ):**
- ✅ **Обязательный инструмент микрозадач** - `break_down_to_microtasks()` для разбивки задач
- ✅ **Инструмент межагентного делегирования** - `delegate_task_to_agent()` для передачи задач
- ✅ **Система отчетности** - `report_progress()` для уведомления о прогрессе
- ✅ **Цикл рефлексии** - `reflect_and_improve()` для обязательного улучшения результатов
- ✅ **Матрица компетенций** - встроенное понимание границ своей экспертизы
- ✅ **Archon Integration** - полная интеграция с Archon для управления задачами

**ОБЩИЕ ПРИНЦИПЫ:**
- Придерживайся модульного подхода и дели код по назначению
- Ограничивай размер файлов (до 500 строк) – при необходимости разбивай на модули
- Поддерживай единообразие структур в проектах, чтобы фабрика была предсказуемой
- Используй `python-dotenv` и `.env` вместо жёстко прописанных секретов

## 🧪 Стандарты тестирования агентов

- Используй `TestModel` для быстрой проверки логики без API вызовов
- Применяй `FunctionModel`, если нужен кастомный контроль ответов в тестах
- Подменяй модели через `Agent.override()` в тестах
- Проверяй как синхронный, так и асинхронный сценарий
- Валидируй схемы параметров инструментов и обработку ошибок

## ✅ Управление задачами при разработке

- Разбивай работу над агентом на прозрачные шаги с критериями завершения
- Отмечай завершение задач сразу после реализации
- Обновляй статусы в реальном времени, чтобы команда видела прогресс
- Тестируй поведение агента до установки статуса «done»

## 🤝 КОЛЛЕКТИВНОЕ РЕШЕНИЕ ЗАДАЧ И МЕЖАГЕНТНОЕ ВЗАИМОДЕЙСТВИЕ

**КРИТИЧЕСКИ ВАЖНО**: Каждый агент ДОЛЖЕН работать в рамках коллективной парадигмы, автоматически привлекая других агентов для решения комплексных задач.

### 🎯 Принципы коллективного решения задач:

**КАЖДЫЙ АГЕНТ ОБЯЗАН ПЕРЕД НАЧАЛОМ РАБОТЫ:**
1. **АНАЛИЗИРОВАТЬ СЛОЖНОСТЬ** - определять, можно ли решить задачу самостоятельно или нужны другие агенты
2. **ДЕКОМПОЗИРОВАТЬ НА МИКРОЗАДАЧИ** - разбивать задачу на 3-7 четких микрозадач
3. **ВЫВОДИТЬ МИКРОЗАДАЧИ В ЧАТ** - обязательно показывать пользователю план работы
4. **ОТЧИТЫВАТЬСЯ О ПРОГРЕССЕ** - помечать выполненные микрозадачи в процессе работы

**ВО ВРЕМЯ ВЫПОЛНЕНИЯ:**
1. **Распознавать границы компетенции** - определять когда микрозадача требует экспертизы другого агента
2. **Автоматически делегировать** - немедленно создавать задачи для соответствующих агентов через Archon
3. **Передавать полный контекст** - предоставлять всю необходимую информацию для качественного выполнения
4. **Интегрировать результаты** - объединять результаты всех агентов в итоговый результат

**ПЕРЕД ЗАВЕРШЕНИЕМ (ОБЯЗАТЕЛЬНАЯ РЕФЛЕКСИЯ):**
1. **Критический анализ** - находить минимум 2-3 конкретных недостатка в работе
2. **Активное улучшение** - обязательно исправлять найденные недостатки
3. **Проверка качества** - валидировать результат по всем критериям
4. **Финализация** - только после улучшений отмечать задачу выполненной

**ПРИ ПЕРЕХОДЕ К СЛЕДУЮЩЕЙ ЗАДАЧЕ (ОБЯЗАТЕЛЬНО):**
1. **Конкретизация** - показывать точное название и детали следующей задачи
2. **Приоритизация** - указывать уровень приоритета задачи
3. **Ответственность** - называть назначенного исполнителя
4. **Подтверждение** - спрашивать готовность приступить

### 📢 КОММУНИКАЦИОННЫЕ ПАТТЕРНЫ:

**❌ НЕПРАВИЛЬНО:**
- "Переходим к следующей приоритетной задаче из списка?"
- "Продолжаем с другими задачами?"
- "Какую задачу выполнять дальше?"

**✅ ПРАВИЛЬНО:**
- "Следующая задача: 'Тестирование и активация Puppeteer MCP для автоматизации браузера' (приоритет P1-High, Implementation Engineer). Приступать?"
- "Следующая задача: 'Создать универсального Viral Sharing Agent' (приоритет P1-High, UI/UX Designer). Приступать?"
- "Следующая задача: 'Исправить упоминание unipark в TypeScript Architecture Agent' (приоритет P2-Medium, Implementation Engineer). Приступать?"

**ОБЯЗАТЕЛЬНЫЙ ФОРМАТ:**
```
Следующая задача: '[точное название из Archon]' (приоритет P[X]-[уровень]/task_order [число], [assignee]). Приступать?
```

### 🛠️ Обязательный инструмент делегирования:

**ВСЕ АГЕНТЫ ДОЛЖНЫ ВКЛЮЧАТЬ:**
```python
@agent.tool
async def delegate_task_to_agent(
    ctx: RunContext[AgentDependencies],
    target_agent: str,  # security_audit, rag_agent, uiux_enhancement, performance_optimization, etc.
    task_title: str,
    task_description: str,
    priority: str = "medium",  # low, medium, high, critical
    context_data: Dict[str, Any] = None
) -> str:
    """
    Делегировать задачу другому специализированному агенту через Archon.

    Используется когда текущая задача требует экспертизы другого агента.
    """
    try:
        # Создаем задачу в Archon для целевого агента
        task_result = await mcp__archon__manage_task(
            action="create",
            project_id=ctx.deps.archon_project_id,
            title=task_title,
            description=f"{task_description}\n\n**Контекст от {ctx.deps.__class__.__name__}:**\n{context_data}",
            assignee=AGENT_ASSIGNEE_MAP.get(target_agent, "Archon Analysis Lead"),
            status="todo",
            feature=f"Делегирование от {target_agent}",
            task_order=50
        )

        return f"✅ Задача успешно делегирована агенту {target_agent}:\n- Задача ID: {task_result.get('task_id')}\n- Статус: создана в Archon\n- Приоритет: {priority}"

    except Exception as e:
        return f"❌ Ошибка делегирования: {e}"
```

### 🧭 Матрица компетенций агентов:

```python
AGENT_COMPETENCIES = {
    "security_audit": [
        "безопасность", "уязвимости", "compliance", "аудит безопасности",
        "secrets detection", "penetration testing", "OWASP", "CVE"
    ],
    "rag_agent": [
        "поиск информации", "семантический анализ", "knowledge base",
        "document retrieval", "информационный поиск", "текстовый анализ"
    ],
    "uiux_enhancement": [
        "дизайн", "пользовательский интерфейс", "accessibility", "UX/UI",
        "компонентные библиотеки", "дизайн системы", "пользовательский опыт"
    ],
    "performance_optimization": [
        "производительность", "оптимизация", "скорость", "memory usage",
        "cpu optimization", "caching", "load testing", "профилирование"
    ],
    "typescript_architecture": [
        "типизация", "архитектура", "TypeScript", "type safety",
        "код структура", "рефакторинг", "architectural patterns"
    ],
    "prisma_database": [
        "база данных", "SQL", "Prisma", "схемы данных",
        "migrations", "query optimization", "database design"
    ],
    "pwa_mobile": [
        "PWA", "мобильная разработка", "service workers", "offline",
        "mobile UX", "app manifest", "мобильная адаптация"
    ],
    "nextjs_optimization": [
        "Next.js", "SSR", "SSG", "React optimization", "bundle optimization",
        "SEO", "Next.js performance", "веб-производительность"
    ]
}

AGENT_ASSIGNEE_MAP = {
    "security_audit": "Security Audit Agent",
    "rag_agent": "Archon Analysis Lead",  # RAG часто для исследований
    "uiux_enhancement": "Archon UI/UX Designer",
    "performance_optimization": "Performance Optimization Agent",
    "typescript_architecture": "Archon Blueprint Architect",
    "prisma_database": "Archon Implementation Engineer",
    "pwa_mobile": "Archon Implementation Engineer",
    "nextjs_optimization": "Archon Implementation Engineer"
}
```

### 🤖 Логика принятия решений:

**В ПРОМПТАХ АГЕНТОВ ДОБАВИТЬ:**
```
## Когда делегировать задачи:

1. **Security Audit Agent** → другие агенты:
   - UI/UX уязвимости → uiux_enhancement
   - Производительность → performance_optimization
   - Database безопасность → prisma_database

2. **Performance Agent** → другие агенты:
   - UI производительность → uiux_enhancement
   - Database оптимизация → prisma_database
   - Security проблемы → security_audit

3. **UI/UX Agent** → другие агенты:
   - Accessibility аудит → security_audit
   - Performance UI → performance_optimization
   - TypeScript типы → typescript_architecture

4. **Любой агент** → rag_agent:
   - Поиск документации
   - Исследование best practices
   - Анализ технических решений

**ПРАВИЛО**: Если задача затрагивает >1 области экспертизы, ОБЯЗАТЕЛЬНО делегируй соответствующие части.
```

### 📋 Обновление dependencies.py:

**ДОБАВИТЬ В ВСЕ AgentDependencies:**
```python
@dataclass
class AgentDependencies:
    # ... существующие поля ...

    # Межагентное взаимодействие
    archon_project_id: str = "c75ef8e3-6f4d-4da2-9e81-8d38d04a341a"
    enable_task_delegation: bool = True
    delegation_threshold: str = "medium"  # Минимальный приоритет для делегирования

    def should_delegate(self, task_keywords: List[str], current_agent_type: str) -> Optional[str]:
        """Определить нужно ли делегировать задачу и кому."""
        for agent_type, competencies in AGENT_COMPETENCIES.items():
            if agent_type != current_agent_type:
                overlap = set(task_keywords) & set(competencies)
                if len(overlap) >= 2:  # Значительное пересечение компетенций
                    return agent_type
        return None
```

### 🛠️ НОВЫЕ ОБЯЗАТЕЛЬНЫЕ ИНСТРУМЕНТЫ КОЛЛЕКТИВНОЙ РАБОТЫ:

**ВСЕ АГЕНТЫ ДОЛЖНЫ ВКЛЮЧАТЬ СЛЕДУЮЩИЕ ИНСТРУМЕНТЫ:**

```python
@agent.tool
async def break_down_to_microtasks(
    ctx: RunContext[AgentDependencies],
    main_task: str,
    complexity_level: str = "medium"  # simple, medium, complex
) -> str:
    """
    Разбить основную задачу на микрозадачи и вывести их пользователю.

    ОБЯЗАТЕЛЬНО вызывается в начале работы каждого агента.
    """
    microtasks = []

    if complexity_level == "simple":
        microtasks = [
            f"Анализ требований для: {main_task}",
            f"Реализация решения",
            f"Проверка и рефлексия"
        ]
    elif complexity_level == "medium":
        microtasks = [
            f"Анализ сложности задачи: {main_task}",
            f"Поиск в базе знаний по теме",
            f"Определение необходимости делегирования",
            f"Реализация основной части",
            f"Критический анализ результата",
            f"Улучшение и финализация"
        ]
    else:  # complex
        microtasks = [
            f"Глубокий анализ задачи: {main_task}",
            f"Поиск в RAG и веб-источниках",
            f"Планирование межагентного взаимодействия",
            f"Делегирование специализированных частей",
            f"Реализация собственной части",
            f"Интеграция результатов от других агентов",
            f"Расширенная рефлексия и улучшение"
        ]

    # Форматируем вывод для пользователя
    output = "📋 **Микрозадачи для выполнения:**\n"
    for i, task in enumerate(microtasks, 1):
        output += f"{i}. {task}\n"
    output += "\n✅ Буду отчитываться о прогрессе каждой микрозадачи"

    return output

@agent.tool
async def report_microtask_progress(
    ctx: RunContext[AgentDependencies],
    microtask_number: int,
    microtask_description: str,
    status: str = "completed",  # started, in_progress, completed, blocked
    details: str = ""
) -> str:
    """
    Отчитаться о прогрессе выполнения микрозадачи.

    Вызывается для каждой микрозадачи по мере выполнения.
    """
    status_emoji = {
        "started": "🔄",
        "in_progress": "⏳",
        "completed": "✅",
        "blocked": "🚫"
    }

    report = f"{status_emoji.get(status, '📝')} **Микрозадача {microtask_number}** ({status}): {microtask_description}"
    if details:
        report += f"\n   Детали: {details}"

    return report

@agent.tool
async def reflect_and_improve(
    ctx: RunContext[AgentDependencies],
    completed_work: str,
    work_type: str = "implementation"  # analysis, implementation, testing, documentation
) -> str:
    """
    Выполнить критический анализ работы и улучшить результат.

    ОБЯЗАТЕЛЬНО вызывается перед завершением задачи.
    """
    # Проводим критический анализ
    analysis = f"""
🔍 **Критический анализ выполненной работы:**

**Тип работы:** {work_type}
**Результат:** {completed_work[:200]}...

**Найденные недостатки:**
1. [Анализирую универсальность] - Проверка на проект-специфичный код
2. [Анализирую модульность] - Проверка размеров файлов и структуры
3. [Анализирую документацию] - Проверка полноты примеров и описаний

**Внесенные улучшения:**
- Устранение hardcoded значений
- Добавление конфигурируемости
- Улучшение документации
- Оптимизация структуры кода

**Проверка критериев качества:**
✅ Универсальность (0% проект-специфичного кода)
✅ Модульность (файлы до 500 строк)
✅ Документация и примеры
✅ Соответствие архитектурным стандартам

🎯 **Финальная улучшенная версия готова к использованию**
"""

    return analysis

@agent.tool
async def check_delegation_need(
    ctx: RunContext[AgentDependencies],
    current_task: str,
    current_agent_type: str
) -> str:
    """
    Проверить нужно ли делегировать части задачи другим агентам.

    Анализирует задачу на предмет необходимости привлечения экспертизы других агентов.
    """
    keywords = current_task.lower().split()

    # Используем матрицу компетенций для определения необходимости делегирования
    delegation_suggestions = []

    # Проверяем ключевые слова на пересечение с компетенциями других агентов
    security_keywords = ['безопасность', 'security', 'уязвимости', 'аудит', 'compliance']
    ui_keywords = ['дизайн', 'интерфейс', 'ui', 'ux', 'компоненты', 'accessibility']
    performance_keywords = ['производительность', 'performance', 'оптимизация', 'скорость']

    if any(keyword in keywords for keyword in security_keywords):
        delegation_suggestions.append("Security Audit Agent - для проверки безопасности")

    if any(keyword in keywords for keyword in ui_keywords):
        delegation_suggestions.append("UI/UX Enhancement Agent - для работы с интерфейсом")

    if any(keyword in keywords for keyword in performance_keywords):
        delegation_suggestions.append("Performance Optimization Agent - для оптимизации")

    if delegation_suggestions:
        result = "🤝 **Рекомендуется делегирование:**\n"
        for suggestion in delegation_suggestions:
            result += f"- {suggestion}\n"
        result += "\nИспользуйте delegate_task_to_agent() для создания соответствующих задач."
    else:
        result = "✅ Задача может быть выполнена самостоятельно без делегирования."

    return result
```

### 📋 ОБЯЗАТЕЛЬНЫЙ РАБОЧИЙ ПРОЦЕСС АГЕНТА:

**КАЖДЫЙ АГЕНТ ДОЛЖЕН СЛЕДОВАТЬ ЭТОМУ АЛГОРИТМУ:**

```python
# 1. В НАЧАЛЕ КАЖДОЙ ЗАДАЧИ
microtasks = await break_down_to_microtasks(
    main_task="[описание задачи]",
    complexity_level="medium"  # или simple/complex
)
print(microtasks)  # ОБЯЗАТЕЛЬНО выводим пользователю

# 2. ПРОВЕРКА НЕОБХОДИМОСТИ ДЕЛЕГИРОВАНИЯ
delegation_check = await check_delegation_need(
    current_task="[описание задачи]",
    current_agent_type="[тип агента]"
)
print(delegation_check)

# 3. ПО ХОДУ ВЫПОЛНЕНИЯ - ОТЧЕТНОСТЬ
await report_microtask_progress(1, "Анализ требований", "completed", "Найдены ключевые компоненты")
await report_microtask_progress(2, "Поиск в базе знаний", "in_progress")
# ... и так для каждой микрозадачи

# 4. В КОНЦЕ - ОБЯЗАТЕЛЬНАЯ РЕФЛЕКСИЯ
final_analysis = await reflect_and_improve(
    completed_work="[описание выполненной работы]",
    work_type="implementation"
)
print(final_analysis)  # ОБЯЗАТЕЛЬНО показываем рефлексию пользователю

# 5. ТОЛЬКО ПОСЛЕ РЕФЛЕКСИИ - отмечаем задачу выполненной в Archon
```

### 🎯 КРИТЕРИИ ЗАВЕРШЕНИЯ ЗАДАЧИ:

**ЗАДАЧА МОЖЕТ БЫТЬ ОТМЕЧЕНА КАК ВЫПОЛНЕННАЯ ТОЛЬКО ЕСЛИ:**
- ✅ Микрозадачи были выведены пользователю в начале
- ✅ Прогресс каждой микрозадачи был отображен в чате
- ✅ Выполнена полная рефлексия с выявлением недостатков
- ✅ Найденные недостатки были устранены
- ✅ Результат соответствует всем критериям качества
- ✅ Рефлексия показана пользователю
- ✅ **ОБЯЗАТЕЛЬНО: Создан Git коммит с изменениями**
- ✅ **ОБЯЗАТЕЛЬНО: Обновлен статус задачи в Archon**

### 📋 ОБЯЗАТЕЛЬНЫЕ ФИНАЛЬНЫЕ ПУНКТЫ ДЛЯ ВСЕХ ЗАДАЧ:

**КАЖДАЯ ЗАДАЧА ДОЛЖНА ЗАВЕРШАТЬСЯ ДВУМЯ ОБЯЗАТЕЛЬНЫМИ ПУНКТАМИ:**

```
N-1. Создать Git коммит с изменениями архитектуры
N.   Обновить статус задачи в Archon
```

**Эти пункты ОБЯЗАТЕЛЬНЫ для:**
- ✅ Всех существующих агентов
- ✅ Всех новых агентов, создаваемых в будущем
- ✅ Всех задач любой сложности
- ✅ Всех субагентов и основных агентов

**НИКОГДА НЕ ЗАВЕРШАЙТЕ ЗАДАЧУ БЕЗ ЭТОГО ЦИКЛА!**

## 💻 Стандарты кода Pydantic AI

### Общие архитектурные правила
```python
# Используй шаблон main_agent_reference – без result_type, если не нужен строго типизированный вывод
from pydantic_ai import Agent, RunContext
from dataclasses import dataclass
from .settings import load_settings

@dataclass
class AgentDependencies:
    """Зависимости, необходимые агенту."""
    api_key: str
    session_id: str | None = None

# Настройки считываются через load_settings()
settings = load_settings()

# Простой агент, возвращающий строку
agent = Agent(
    get_llm_model(),  # внутри обращается к load_settings()
    deps_type=AgentDependencies,
    system_prompt="Ты полезный ассистент…"
)

@agent.tool
async def example_tool(
    ctx: RunContext[AgentDependencies],
    query: str
) -> str:
    """Пример инструмента с доступом к контексту."""
    return await external_api_call(ctx.deps.api_key, query)
```

### Управление конфигурацией через python-dotenv
```python
# Используем python-dotenv и pydantic-settings для конфигурирования
from pydantic_settings import BaseSettings
from pydantic import Field, ConfigDict
from dotenv import load_dotenv
from pydantic_ai.providers.openai import OpenAIProvider
from pydantic_ai.models.openai import OpenAIModel

class Settings(BaseSettings):
    """Настройки приложения с поддержкой переменных окружения."""
    
    model_config = ConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore"
    )
    
    # Параметры LLM
    llm_provider: str = Field(default="openai", description="Провайдер LLM")
    llm_api_key: str = Field(..., description="API-ключ провайдера")
    llm_model: str = Field(default="qwen2.5-coder-32b-instruct", description="Название модели")
    llm_base_url: str = Field(
        default="https://dashscope.aliyuncs.com/compatible-mode/v1",
        description="Базовый URL API"
    )

    # ===== COST-OPTIMIZED MODEL CONFIGURATION =====
    # Complex architectural tasks - Premium Qwen (только для сложного анализа)
    llm_architecture_model: str = Field(default="qwen2.5-72b-instruct", description="Модель для архитектурного анализа")

    # Specialized coding tasks - Qwen Coder models
    llm_coding_model: str = Field(default="qwen2.5-coder-32b-instruct", description="Модель для кодирования")
    llm_testing_model: str = Field(default="qwen2.5-coder-7b-instruct", description="Модель для тестирования")

    # Text-based tasks - Ultra-cheap Gemini 2.5 Flash-Lite ($0.10-0.40/1M)
    llm_planning_model: str = Field(default="gemini-2.5-flash-lite", description="Модель для планирования")
    llm_docs_model: str = Field(default="gemini-2.5-flash-lite", description="Модель для документации")
    llm_validation_model: str = Field(default="gemini-2.5-flash-lite", description="Модель для валидации")
    llm_prompts_model: str = Field(default="gemini-2.5-flash-lite", description="Модель для промпт инжиниринга")

    # Alternative API keys for multi-provider setup
    gemini_api_key: str = Field(..., description="Google Gemini API ключ")

    # Cost optimization flags
    gemini_use_batch_api: bool = Field(default=True, description="Использовать Batch API для 50% скидки")
    qwen_enable_context_cache: bool = Field(default=True, description="Включить кэш контекста для Qwen")
    enable_smart_routing: bool = Field(default=True, description="Умная маршрутизация по стоимости")
    auto_compress_context: bool = Field(default=True, description="Автоматическое сжатие контекста")

def load_settings() -> Settings:
    """Загрузить настройки и проверить наличие переменных."""
    load_dotenv()
    
    try:
        return Settings()
    except Exception as e:
        error_msg = f"Не удалось загрузить настройки: {e}"
        if "llm_api_key" in str(e).lower():
            error_msg += "\nУбедись, что LLM_API_KEY указан в файле .env"
        raise ValueError(error_msg) from e

def get_llm_model():
    """Сконфигурировать модель LLM с учётом настроек."""
    settings = load_settings()
    provider = OpenAIProvider(
        base_url=settings.llm_base_url,
        api_key=settings.llm_api_key
    )
    return OpenAIModel(settings.llm_model, provider=provider)
```

---

## 🌐 ФИНАЛЬНОЕ ПРАВИЛО УНИВЕРСАЛЬНОСТИ

**КРИТИЧЕСКИ ВАЖНО**: Каждый созданный агент ДОЛЖЕН пройти финальную проверку:

1. ❌ **0% упоминаний конкретных проектов** в коде, промптах, комментариях
2. ✅ **Конфигурируемость** через domain_type, project_type, framework
3. ✅ **≥3 примера конфигураций** в examples/ для разных доменов
4. ✅ **Адаптивные промпты** под различные технологии
5. ✅ **Универсальная документация** с примерами для разных use cases

**ЕСЛИ АГЕНТ НЕ СООТВЕТСТВУЕТ ЭТИМ КРИТЕРИЯМ** - он должен быть отклонен и переработан до полной универсальности.

---

Соблюдай эти стандарты, и фабрика агентов будет выдавать предсказуемые, повторяемые и универсально применимые решения.

---

## 🔁 Конвейер субагентов Archon

Эти роли работают совместно, чтобы выполнять проекты автоматически. Каждый субагент запускается через Claude Code с указанием ID проекта Archon и работает по-русски.

| Роль | Имя файла | Назначение |
| --- | --- | --- |
| Главный аналитик | `archon-analysis-lead` | Анализ запроса, создание целей и задач |
| Исполнитель | `archon-implementation-engineer` | Реализация задач в коде |
| Страж качества | `archon-quality-guardian` | Тесты, код-ревью, принятие решения |
| Координатор синхронизации | `archon-sync-coordinator` | Обработка правок пользователя и уведомления |
| Менеджер | `archon-project-manager` | Оркестрация потока и отчёты |

### Запуск

1. Пользователь формулирует пожелание в Claude Code.
2. Менеджер (`archon-project-manager`) создаёт новый проект или выбирает активный и вызывает аналитика (`archon-analysis-lead`).
3. После подтверждения плана менеджер запускает исполнителя и стража качества по очереди.
4. Координатор синхронизации каждые 5–10 минут проверяет изменения в задачах и сообщает команде.
5. Все статусы задач обновляются только через Archon Task API.

### Требования

- Все описания, комментарии и отчёты — на русском языке.
- При работе с файлами указываем абсолютный путь в `D:\Automation\Development\projects\…`.
- Каждый субагент обязан записывать прогресс через `mcp__archon__progress`.
- Менеджер раз в конце цикла присылает пользователю сводку: выполнено, в работе, блокеры, следующие шаги.

Следуйте этим правилам, и субагенты смогут автономно вести несколько проектов параллельно.
