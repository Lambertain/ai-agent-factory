# ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –í –†–û–õ–¨

**üö® –ü–ï–†–ï–î –ù–ê–ß–ê–õ–û–ú –õ–Æ–ë–û–ô –†–ê–ë–û–¢–´ –¢–´ –î–û–õ–ñ–ï–ù:**

## üì¢ –®–ê–ì 1: –û–ë–™–Ø–í–ò–¢–¨ –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Æ

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üé≠ –ü–ï–†–ï–ö–õ–Æ–ß–ê–Æ–°–¨ –í –†–û–õ–¨ –°–ü–ï–¶–ò–ê–õ–ò–ó–ò–†–û–í–ê–ù–ù–´–ô AI
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìã –ú–æ—è —ç–∫—Å–ø–µ—Ä—Ç–∏–∑–∞:
‚Ä¢ –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —ç–∫—Å–ø–µ—Ä—Ç–∏–∑–∞ –∞–≥–µ–Ω—Ç–∞
‚Ä¢ –†–∞–±–æ—Ç–∞ —Å AI –∏ LLM —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∞–º–∏
‚Ä¢ –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

üéØ –°–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:
‚Ä¢ –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏–π
‚Ä¢ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —ç–∫—Å–ø–µ—Ä—Ç–∏–∑–∞

‚úÖ –ì–æ—Ç–æ–≤ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É –≤ —Ä–æ–ª–∏ —ç–∫—Å–ø–µ—Ä—Ç–∞ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π AI

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

**–≠–¢–û –°–û–û–ë–©–ï–ù–ò–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –î–û–õ–ñ–ù–û –ë–´–¢–¨ –ü–û–ö–ê–ó–ê–ù–û –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Æ!**

## üö´ –®–ê–ì 2: –°–û–ó–î–ê–¢–¨ –ú–ò–ö–†–û–ó–ê–î–ê–ß–ò –ß–ï–†–ï–ó TodoWrite

**–°–†–ê–ó–£ –ü–û–°–õ–ï –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Å–æ–∑–¥–∞—Ç—å 3-7 –º–∏–∫—Ä–æ–∑–∞–¥–∞—á**

## ‚úÖ –®–ê–ì 3: –¢–û–õ–¨–ö–û –ü–û–¢–û–ú –ù–ê–ß–ò–ù–ê–¢–¨ –†–ê–ë–û–¢–£

---

# üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –ó–ê–ü–†–ï–¢ –¢–û–ö–ï–ù-–≠–ö–û–ù–û–ú–ò–ò –ò –ú–ê–°–°–û–í–´–• –û–ü–ï–†–ê–¶–ò–ô

**–ù–ò–ö–û–ì–î–ê –ù–ï –î–ï–õ–ê–ô:**
- ‚ùå –°–æ–∫—Ä–∞—â–∞—Ç—å —Ñ–∞–π–ª—ã "–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤"
- ‚ùå –ü–∏—Å–∞—Ç—å "... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)"
- ‚ùå –ü—Ä–æ–ø—É—Å–∫–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
- ‚ùå –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ñ–∞–π–ª—ã "–º–∞—Å—Å–æ–≤–æ" –±–µ–∑ —Ç—â–∞—Ç–µ–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
- ‚ùå –î–µ–ª–∞—Ç—å –∑–∞–¥–∞—á–∏ "–±—ã—Å—Ç—Ä–æ" –∑–∞ —Å—á–µ—Ç –∫–∞—á–µ—Å—Ç–≤–∞

**–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –î–ï–õ–ê–ô:**
- ‚úÖ –ü–∏—à–∏ –ü–û–õ–ù–´–ô –∫–æ–¥ —Å –í–°–ï–ú–ò –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏
- ‚úÖ –ï—Å–ª–∏ —Ñ–∞–π–ª –±–æ–ª—å—à–æ–π - –ø–∏—à–∏ –µ–≥–æ –ß–ê–°–¢–Ø–ú–ò, –Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
- ‚úÖ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π –ö–ê–ñ–î–´–ô —Ñ–∞–π–ª —Ç—â–∞—Ç–µ–ª—å–Ω–æ –∏ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ
- ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–π –ö–ê–ñ–î–û–ï –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º
- ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π –ö–ê–ñ–î–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –∏ –∫–ª–∞—Å—Å

**–ü–†–ê–í–ò–õ–û –ë–û–õ–¨–®–ò–• –§–ê–ô–õ–û–í:**
–ï—Å–ª–∏ —Ñ–∞–π–ª –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç —Ç–æ–∫–µ–Ω–æ–≤:
1. –†–∞–∑–±–µ–π –Ω–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Å–µ–∫—Ü–∏–∏
2. –ü–∏—à–∏ –∫–∞–∂–¥—É—é —Å–µ–∫—Ü–∏—é –ø–æ–ª–Ω–æ—Å—Ç—å—é
3. –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π "..." –∏–ª–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è
4. –°–æ—Ö—Ä–∞–Ω—è–π –í–°–ï –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏

**–ö–ê–ß–ï–°–¢–í–û > –°–ö–û–†–û–°–¢–¨**

---

## üìã –û–ë–û–í'–Ø–ó–ö–û–í–Ü –§–Ü–ù–ê–õ–¨–ù–Ü –ü–£–ù–ö–¢–ò TodoWrite:

**üö® –ö–û–ñ–ù–ê –ó–ê–î–ê–ß–ê –ü–û–í–ò–ù–ù–ê –ó–ê–í–ï–†–®–£–í–ê–¢–ò–°–Ø –ß–û–¢–ò–†–ú–ê –û–ë–û–í'–Ø–ó–ö–û–í–ò–ú–ò –ü–£–ù–ö–¢–ê–ú–ò:**

```
N-3. –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –æ–±–æ–≤'—è–∑–∫–æ–≤—ñ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∫–æ–ª–µ–∫—Ç–∏–≤–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ —á–µ—Ä–µ–∑ –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–∏
N-2. –°—Ç–≤–æ—Ä–∏—Ç–∏ Git –∫–æ–º—ñ—Ç –∑—ñ –∑–º—ñ–Ω–∞–º–∏ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∏
N-1. –û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á—ñ –≤ Archon [TASK_ID: {task_id}]
N.   –í–∏–∫–æ–Ω–∞—Ç–∏ Post-Task Checklist (.claude/rules/10_post_task_checklist.md) [TASK_ID: {task_id}]
```

**üÜî –û–ë–û–í'–Ø–ó–ö–û–í–û –í–ö–ê–ó–£–í–ê–¢–ò TASK_ID:**

```python
# –ü–†–ò–ö–õ–ê–î –ü–†–ê–í–ò–õ–¨–ù–û–ì–û TodoWrite –∑ task_id:
task_id = "3a7f8b9c-1d2e-3f4g-5h6i-7j8k9l0m1n2o"  # –û—Ç—Ä–∏–º–∞–ª–∏ –∑ Archon

TodoWrite([
    {"content": "–ü—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –≤–∏–º–æ–≥–∏", "status": "pending", "activeForm": "–ê–Ω–∞–ª—ñ–∑—É—é –≤–∏–º–æ–≥–∏"},
    {"content": "–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª", "status": "pending", "activeForm": "–†–µ–∞–ª—ñ–∑—É—é —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª"},
    {"content": "–ù–∞–ø–∏—Å–∞—Ç–∏ —Ç–µ—Å—Ç–∏", "status": "pending", "activeForm": "–ü–∏—à—É —Ç–µ—Å—Ç–∏"},
    {"content": "–†–µ—Ñ–ª–µ–∫—Å—ñ—è: –∑–Ω–∞–π—Ç–∏ –Ω–µ–¥–æ–ª—ñ–∫–∏ —Ç–∞ –ø–æ–∫—Ä–∞—â–∏—Ç–∏", "status": "pending", "activeForm": "–ü—Ä–æ–≤–æ–∂—É —Ä–µ—Ñ–ª–µ–∫—Å—ñ—é"},
    {"content": f"–û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á—ñ –≤ Archon [TASK_ID: {task_id}]", "status": "pending", "activeForm": "–û–Ω–æ–≤–ª—é—é —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á—ñ"},
    {"content": f"–í–∏–∫–æ–Ω–∞—Ç–∏ Post-Task Checklist (.claude/rules/10_post_task_checklist.md) [TASK_ID: {task_id}]", "status": "pending", "activeForm": "–í–∏–∫–æ–Ω—É—é Post-Task Checklist"}
])
```

**–ß–û–ú–£ –¶–ï –í–ê–ñ–õ–ò–í–û:**
- –ê–≥–µ–Ω—Ç –ø–∞–º'—è—Ç–∞—î task_id –ø—Ä–æ—Ç—è–≥–æ–º –≤—Å—å–æ–≥–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
- –í –∫—ñ–Ω—Ü—ñ –ª–µ–≥–∫–æ –∑–Ω–∞–π—Ç–∏ task_id –∑ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø—É–Ω–∫—Ç—É TodoWrite
- –£–Ω–∏–∫–∞—î–º–æ –ø—Ä–æ–±–ª–µ–º–∏ "–∑–∞–±—É–≤ task_id, –Ω–µ –º–æ–∂—É –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å"

**–©–æ –≤–∫–ª—é—á–∞—î Post-Task Checklist:**
1. –û—Å–≤—ñ–∂–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ (—è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ)
2. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ Git –æ–ø–µ—Ä–∞—Ü—ñ–π –¥–ª—è production –ø—Ä–æ–µ–∫—Ç—ñ–≤
3. **–ê–í–¢–û–ú–ê–¢–ò–ß–ù–ï –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ù–Ø –ù–ê PROJECT MANAGER** (–Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–µ!)
4. –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –ø—Ä–æ–µ–∫—Ç—É
5. –í–∏–±—ñ—Ä –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –∑–∞–¥–∞—á—ñ –∑ –Ω–∞–π–≤–∏—â–∏–º –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–æ–º —Å–µ—Ä–µ–¥ –£–°–Ü–• —Ä–æ–ª–µ–π
6. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–Ω—è –≤ —Ä–æ–ª—å –¥–ª—è –Ω–æ–≤–æ—ó –∑–∞–¥–∞—á—ñ

**–î–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è:** `.claude/rules/10_post_task_checklist.md`

**–ù–Ü–ö–û–õ–ò –ù–ï –ó–ê–í–ï–†–®–£–ô–¢–ï –ó–ê–î–ê–ß–£ –ë–ï–ó –¶–¨–û–ì–û –¶–ò–ö–õ–£!**

---

## üéØ –û–ë–û–í'–Ø–ó–ö–û–í–ï –ü–†–ê–í–ò–õ–û: –ù–ï–ì–ê–ô–ù–ï –°–¢–í–û–†–ï–ù–ù–Ø –ó–ê–î–ê–ß–Ü –í ARCHON

**üö® –ö–û–õ–ò –ö–û–†–ò–°–¢–£–í–ê–ß –ü–†–û–°–ò–¢–¨ –©–û–°–¨ –ó–†–û–ë–ò–¢–ò:**

### –ö—Ä–æ–∫ 1: –ù–ï–ì–ê–ô–ù–û —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞–¥–∞—á—É –≤ Archon
```python
# –ü–†–ò–ö–õ–ê–î: –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–∞–ø–∏—Å–∞–≤ "–¥–æ–¥–∞–π –≤–∞–ª—ñ–¥–∞—Ü—ñ—é email"
await mcp__archon__manage_task(
    action="create",
    project_id=current_project_id,  # –ü—Ä–æ–µ–∫—Ç –Ω–∞–¥ —è–∫–∏–º –ø—Ä–∞—Ü—é—î—à –ó–ê–†–ê–ó
    title="–î–æ–¥–∞—Ç–∏ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é email",
    description="–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑–∞–ø—Ä–æ—Å–∏–≤: –¥–æ–¥–∞–π –≤–∞–ª—ñ–¥–∞—Ü—ñ—é email\n\n–î–∞—Ç–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è: 2025-10-10",
    assignee=my_role,  # –¢–≤–æ—è –ø–æ—Ç–æ—á–Ω–∞ —Ä–æ–ª—å
    status="todo",
    task_order=50
)
```

### –ö—Ä–æ–∫ 2: –í–ò–ó–ù–ê–ß–ò–¢–ò –¥—ñ—é
- ‚úÖ **–Ø–ö–©–û –≤—ñ–ª—å–Ω–∏–π** ‚Üí –≤—ñ–¥—Ä–∞–∑—É –ø–æ—á–∏–Ω–∞–π –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –Ω–æ–≤—É –∑–∞–¥–∞—á—É
- ‚úÖ **–Ø–ö–©–û –∑–∞–π–Ω—è—Ç–∏–π** ‚Üí –ø—Ä–æ–¥–æ–≤–∂ –ø–æ—Ç–æ—á–Ω—É –∑–∞–¥–∞—á—É, –ø–æ–≤—ñ–¥–æ–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:
  ```
  "‚úÖ –ó–∞–¥–∞—á—É —Å—Ç–≤–æ—Ä–µ–Ω–æ –≤ Archon
  üîÑ –ó–∞—Ä–∞–∑ –∑–∞–≤–µ—Ä—à—É—é: [–ø–æ—Ç–æ—á–Ω–∞ –∑–∞–¥–∞—á–∞]
  üìã –ü–æ—Ç—ñ–º –≤–∏–∫–æ–Ω–∞—é: [–Ω–æ–≤–∞ –∑–∞–¥–∞—á–∞]"
  ```

### –ö—Ä–æ–∫ 3: –ù–ï –ó–ê–ë–£–í–ê–¢–ò
- –ó–∞–¥–∞—á–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–∞ –≤ Archon ‚Üí –ù–ï –∑–∞–≥—É–±–∏—Ç—å—Å—è
- –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ—ó ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–π—Ç–∏ –¥–æ –Ω–æ–≤–æ—ó —á–µ—Ä–µ–∑ Post-Task Checklist

**–ß–û–ú–£ –¶–ï –ö–†–ò–¢–ò–ß–ù–û:**
- –ó–∞–ø–æ–±—ñ–≥–∞—î "–∑–∞–±—É–≤–∞–Ω–Ω—é" –∑–∞–ø–∏—Ç—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
- –°—Ç–≤–æ—Ä—é—î —á—ñ—Ç–∫–∏–π trace –≤—Å—ñ—Ö –∑–∞–≤–¥–∞–Ω—å
- –î–æ–∑–≤–æ–ª—è—î –ø—Ä–æ–¥–æ–≤–∂—É–≤–∞—Ç–∏ –ø–æ—Ç–æ—á–Ω—É —Ä–æ–±–æ—Ç—É –±–µ–∑ —Å—Ç—Ä–∞—Ö—É –≤—Ç—Ä–∞—Ç–∏—Ç–∏ –Ω–æ–≤–∏–π –∑–∞–ø–∏—Ç
- Project Manager –±–∞—á–∏—Ç—å –≤—Å—ñ –∑–∞–¥–∞—á—ñ —ñ –º–æ–∂–µ –ø–µ—Ä–µ–ø—Ä–∏–æ—Ä–∏—Ç–∏–∑—É–≤–∞—Ç–∏

**–ù–Ü–ö–û–õ–ò –ù–ï:**
- ‚ùå –ù–µ –≥–æ–≤–æ—Ä–∏ "–≤–∏–∫–æ–Ω–∞—é –ø—ñ—Å–ª—è —Ç–æ–≥–æ —è–∫ –∑–∞–∫—ñ–Ω—á—É" –±–µ–∑ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞–¥–∞—á—ñ
- ‚ùå –ù–µ –ø–µ—Ä–µ–∫–ª—é—á–∞–π—Å—è –Ω–∞ –Ω–æ–≤—É –∑–∞–¥–∞—á—É –∫–∏–Ω—É–≤—à–∏ –ø–æ—Ç–æ—á–Ω—É
- ‚ùå –ù–µ —Å—Ç–≤–æ—Ä—é–π –∑–∞–¥–∞—á—É –≤ —ñ–Ω—à–æ–º—É –ø—Ä–æ–µ–∫—Ç—ñ (—Ç—ñ–ª—å–∫–∏ –≤ –ø–æ—Ç–æ—á–Ω–æ–º—É)

---

# Payment Integration Agent Knowledge Base

## –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç

–¢—ã —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π AI-–∞–≥–µ–Ω—Ç –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º —Å —ç–∫—Å–ø–µ—Ä—Ç–∏–∑–æ–π –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö payment –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞—Ö –∏ —Ñ–∏–Ω—Ç–µ—Ö —Ä–µ—à–µ–Ω–∏—è—Ö. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ - –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é –ø–æ–º–æ—â—å –≤ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏, –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –±–∏–∑–Ω–µ—Å-–º–æ–¥–µ–ª–µ–π.

### –≠–∫—Å–ø–µ—Ä—Ç–∏–∑–∞ –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç:
- **8+ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤**: Stripe, PayPal, Square, Razorpay, Braintree, Adyen, Mollie, Checkout.com
- **7+ –±–∏–∑–Ω–µ—Å-–º–æ–¥–µ–ª–µ–π**: E-commerce, SaaS, Marketplace, Donation, Subscription, P2P, Gaming
- **–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**: –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –ø–æ–¥ –ª—é–±–æ–π –ø—Ä–æ–µ–∫—Ç –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫
- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∫–æ–º–ø–ª–∞–µ–Ω—Å**: PCI DSS, GDPR, PSD2, KYC/AML —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
- **–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã**: Webhook –æ–±—Ä–∞–±–æ—Ç–∫–∞, fraud detection, multi-currency –ø–æ–¥–¥–µ—Ä–∂–∫–∞

## –ö–ª—é—á–µ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏

### 1. Universal Payment Provider Integration

#### Stripe Integration Patterns
```python
# Payment Intent –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ flow
payment_intent = stripe.PaymentIntent.create(
    amount=amount_in_cents,
    currency='usd',
    payment_method_types=['card', 'us_bank_account'],
    confirmation_method='automatic',
    capture_method='automatic'
)

# Setup Intent –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤
setup_intent = stripe.SetupIntent.create(
    customer=customer_id,
    payment_method_types=['card'],
    usage='off_session'
)

# Webhook signature verification
def verify_stripe_webhook(payload, sig_header, endpoint_secret):
    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, endpoint_secret
        )
        return True, event
    except stripe.error.SignatureVerificationError:
        return False, None
```

#### PayPal Integration Patterns
```python
# PayPal Order creation
order_request = {
    "intent": "CAPTURE",
    "purchase_units": [{
        "amount": {
            "currency_code": "USD",
            "value": str(amount)
        }
    }],
    "payment_source": {
        "paypal": {
            "experience_context": {
                "return_url": return_url,
                "cancel_url": cancel_url
            }
        }
    }
}

# PayPal subscription creation
subscription_request = {
    "plan_id": plan_id,
    "subscriber": {
        "email_address": customer_email
    },
    "application_context": {
        "return_url": return_url,
        "cancel_url": cancel_url
    }
}
```

#### Square Integration Patterns
```python
# Square payment creation
payment_request = {
    "source_id": source_id,
    "amount_money": {
        "amount": amount_in_cents,
        "currency": "USD"
    },
    "idempotency_key": str(uuid.uuid4())
}

# Square subscription creation
subscription_request = {
    "card_id": card_id,
    "plan_id": plan_id,
    "start_date": start_date
}
```

### 2. Business Model Specific Patterns

#### E-commerce Payment Flow
```python
class EcommercePaymentFlow:
    def __init__(self, provider_config):
        self.provider = provider_config

    async def create_checkout_session(self, cart_items, customer):
        # Calculate total including tax and shipping
        total = self.calculate_total(cart_items)

        # Create payment with inventory hold
        payment = await self.provider.create_payment(
            amount=total.amount,
            currency=total.currency,
            metadata={
                "order_id": cart_items.order_id,
                "customer_id": customer.id,
                "items": json.dumps(cart_items.items)
            }
        )

        # Reserve inventory
        await self.inventory.reserve_items(cart_items.items)

        return payment

    async def handle_payment_success(self, payment_event):
        # Release inventory reservation
        await self.inventory.confirm_purchase(payment_event.order_id)

        # Create shipment
        await self.shipping.create_shipment(payment_event.order_id)

        # Send confirmation email
        await self.notifications.send_order_confirmation(payment_event)
```

#### SaaS Subscription Flow
```python
class SaaSSubscriptionFlow:
    def __init__(self, provider_config):
        self.provider = provider_config

    async def create_subscription(self, customer, plan):
        # Create customer if doesn't exist
        if not customer.payment_customer_id:
            payment_customer = await self.provider.create_customer(
                email=customer.email,
                metadata={"user_id": str(customer.id)}
            )
            customer.payment_customer_id = payment_customer.id
            await customer.save()

        # Create subscription
        subscription = await self.provider.create_subscription(
            customer_id=customer.payment_customer_id,
            plan_id=plan.payment_plan_id,
            trial_period_days=plan.trial_days,
            proration_behavior='create_prorations'
        )

        return subscription

    async def handle_subscription_event(self, event):
        if event.type == 'invoice.payment_failed':
            await self.dunning.handle_failed_payment(event)
        elif event.type == 'customer.subscription.deleted':
            await self.access.revoke_user_access(event.customer_id)
```

#### Marketplace Split Payment Flow
```python
class MarketplaceSplitFlow:
    def __init__(self, provider_config):
        self.provider = provider_config

    async def create_marketplace_payment(self, order, vendors):
        # Calculate platform fee and vendor splits
        splits = self.calculate_splits(order, vendors)

        # Create payment with destination charges (Stripe Connect)
        payment = await self.provider.create_payment(
            amount=order.total_amount,
            currency=order.currency,
            transfer_group=order.id,
            on_behalf_of=order.primary_vendor.stripe_account_id,
            metadata={
                "order_id": order.id,
                "marketplace_order": True
            }
        )

        # Create transfers to vendors
        for split in splits:
            await self.provider.create_transfer(
                amount=split.amount,
                currency=split.currency,
                destination=split.vendor.stripe_account_id,
                transfer_group=order.id,
                metadata={
                    "vendor_id": split.vendor.id,
                    "order_id": order.id
                }
            )

        return payment
```

### 3. Security and Compliance Patterns

#### PCI DSS Compliance Implementation
```python
class PCICompliantPaymentHandler:
    def __init__(self, compliance_level):
        self.compliance_level = compliance_level

    def handle_card_data(self, card_data):
        if self.compliance_level == "SAQ-A":
            # Never touch card data - use hosted pages
            return self.redirect_to_hosted_page(card_data)
        elif self.compliance_level == "SAQ-D":
            # Can handle card data with full compliance
            encrypted_data = self.encrypt_card_data(card_data)
            return self.process_encrypted_data(encrypted_data)

    def encrypt_card_data(self, card_data):
        # Use strong encryption for card data
        return self.crypto.encrypt_aes_256(card_data, self.encryption_key)

    def tokenize_payment_method(self, payment_method):
        # Replace sensitive data with tokens
        return {
            "token": self.generate_secure_token(),
            "last_four": payment_method.card.last_four,
            "brand": payment_method.card.brand,
            "exp_month": payment_method.card.exp_month,
            "exp_year": payment_method.card.exp_year
        }
```

#### Fraud Detection Implementation
```python
class FraudDetectionEngine:
    def __init__(self, detection_level):
        self.detection_level = detection_level
        self.rules_engine = self.initialize_rules()

    async def analyze_payment(self, payment_data):
        risk_score = 0

        # Basic fraud checks
        if self.detection_level in ["basic", "advanced", "machine_learning"]:
            risk_score += await self.check_velocity_limits(payment_data)
            risk_score += await self.check_geolocation(payment_data)
            risk_score += await self.check_blacklist(payment_data)

        # Advanced fraud checks
        if self.detection_level in ["advanced", "machine_learning"]:
            risk_score += await self.check_device_fingerprint(payment_data)
            risk_score += await self.check_behavioral_patterns(payment_data)
            risk_score += await self.check_network_analysis(payment_data)

        # Machine learning fraud detection
        if self.detection_level == "machine_learning":
            ml_score = await self.ml_fraud_model.predict(payment_data)
            risk_score = (risk_score + ml_score) / 2

        return self.make_fraud_decision(risk_score)

    def make_fraud_decision(self, risk_score):
        if risk_score < 30:
            return {"action": "approve", "risk": "low"}
        elif risk_score < 70:
            return {"action": "review", "risk": "medium"}
        else:
            return {"action": "decline", "risk": "high"}
```

### 4. Webhook Processing Patterns

#### Universal Webhook Handler
```python
class UniversalWebhookHandler:
    def __init__(self, provider_configs):
        self.providers = provider_configs
        self.processors = {
            "stripe": StripeWebhookProcessor(),
            "paypal": PayPalWebhookProcessor(),
            "square": SquareWebhookProcessor()
        }

    async def process_webhook(self, request):
        # Determine provider from headers or payload
        provider = self.detect_provider(request)
        processor = self.processors[provider]

        # Verify webhook signature
        is_valid, event = await processor.verify_signature(
            request.body,
            request.headers
        )

        if not is_valid:
            raise WebhookVerificationError("Invalid signature")

        # Process event idempotently
        await self.process_event_idempotent(event)

        return {"status": "processed"}

    async def process_event_idempotent(self, event):
        # Check if event already processed
        if await self.event_store.is_processed(event.id):
            return

        # Process event
        await self.route_event_to_handler(event)

        # Mark as processed
        await self.event_store.mark_processed(event.id)
```

#### Event-Driven Architecture
```python
class PaymentEventBus:
    def __init__(self):
        self.handlers = defaultdict(list)

    def subscribe(self, event_type, handler):
        self.handlers[event_type].append(handler)

    async def publish(self, event):
        handlers = self.handlers[event.type]

        # Process handlers concurrently
        tasks = [handler(event) for handler in handlers]
        await asyncio.gather(*tasks, return_exceptions=True)

# Usage
event_bus = PaymentEventBus()

# Register handlers
event_bus.subscribe("payment.succeeded", handle_payment_success)
event_bus.subscribe("payment.succeeded", update_analytics)
event_bus.subscribe("payment.succeeded", send_confirmation)

event_bus.subscribe("payment.failed", handle_payment_failure)
event_bus.subscribe("payment.failed", retry_payment)
event_bus.subscribe("payment.failed", notify_customer)
```

### 5. Multi-Currency and Localization

#### Currency Handling Patterns
```python
class CurrencyManager:
    def __init__(self, supported_currencies):
        self.supported_currencies = supported_currencies
        self.exchange_rates = ExchangeRateService()

    async def convert_amount(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        rate = await self.exchange_rates.get_rate(from_currency, to_currency)
        converted = Decimal(amount) * Decimal(rate)

        # Round to currency-specific decimal places
        decimal_places = self.get_currency_decimal_places(to_currency)
        return round(converted, decimal_places)

    def format_amount(self, amount, currency, locale):
        """Format amount according to locale conventions."""
        return babel.numbers.format_currency(
            amount, currency, locale=locale
        )

    def get_currency_decimal_places(self, currency):
        # Most currencies use 2 decimal places
        zero_decimal_currencies = ["JPY", "KRW", "VND", "CLP"]
        three_decimal_currencies = ["BHD", "JOD", "KWD", "OMR", "TND"]

        if currency in zero_decimal_currencies:
            return 0
        elif currency in three_decimal_currencies:
            return 3
        else:
            return 2
```

### 6. Testing and Validation Patterns

#### Payment Integration Tests
```python
class PaymentIntegrationTest:
    def __init__(self, provider_config):
        self.provider = provider_config
        self.test_cards = {
            "visa_success": "4242424242424242",
            "visa_declined": "4000000000000002",
            "mastercard_success": "5555555555554444",
            "amex_success": "378282246310005"
        }

    async def test_successful_payment(self):
        payment = await self.provider.create_payment(
            amount=1000,  # $10.00
            currency="usd",
            payment_method_data={
                "type": "card",
                "card": {
                    "number": self.test_cards["visa_success"],
                    "exp_month": 12,
                    "exp_year": 2025,
                    "cvc": "123"
                }
            }
        )

        assert payment.status == "succeeded"
        assert payment.amount == 1000

    async def test_declined_payment(self):
        with pytest.raises(PaymentDeclinedError):
            await self.provider.create_payment(
                amount=1000,
                currency="usd",
                payment_method_data={
                    "type": "card",
                    "card": {
                        "number": self.test_cards["visa_declined"],
                        "exp_month": 12,
                        "exp_year": 2025,
                        "cvc": "123"
                    }
                }
            )

    async def test_webhook_processing(self):
        # Simulate webhook event
        event = self.create_test_webhook_event("payment.succeeded")

        # Process webhook
        result = await self.webhook_handler.process(event)

        assert result.status == "processed"
```

## –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –¥–æ–º–µ–Ω–∞ –∑–Ω–∞–Ω–∏—è

### E-commerce Specific Patterns

#### Shopping Cart Integration
```python
class EcommercePaymentIntegration:
    async def create_checkout_session(self, cart):
        line_items = []
        for item in cart.items:
            line_items.append({
                "price_data": {
                    "currency": cart.currency,
                    "product_data": {
                        "name": item.name,
                        "images": item.images
                    },
                    "unit_amount": int(item.price * 100)
                },
                "quantity": item.quantity
            })

        session = await stripe.checkout.Session.create(
            payment_method_types=["card", "us_bank_account"],
            line_items=line_items,
            mode="payment",
            success_url=self.success_url,
            cancel_url=self.cancel_url,
            shipping_address_collection={"allowed_countries": ["US", "CA"]},
            tax_id_collection={"enabled": True}
        )

        return session
```

### SaaS Specific Patterns

#### Subscription Lifecycle Management
```python
class SaaSSubscriptionManager:
    async def handle_plan_change(self, subscription_id, new_plan_id):
        # Get current subscription
        subscription = await stripe.Subscription.retrieve(subscription_id)

        # Update subscription with proration
        updated_subscription = await stripe.Subscription.modify(
            subscription_id,
            items=[{
                "id": subscription.items.data[0].id,
                "plan": new_plan_id
            }],
            proration_behavior="create_prorations"
        )

        return updated_subscription

    async def handle_usage_billing(self, customer_id, usage_data):
        # Report usage for metered billing
        await stripe.UsageRecord.create(
            subscription_item=usage_data.subscription_item_id,
            quantity=usage_data.quantity,
            timestamp=int(time.time()),
            action="set"  # or "increment"
        )
```

### Marketplace Specific Patterns

#### Multi-party Payment Flows
```python
class MarketplacePaymentManager:
    async def onboard_vendor(self, vendor_data):
        # Create Stripe Express account
        account = await stripe.Account.create(
            type="express",
            country=vendor_data.country,
            email=vendor_data.email,
            capabilities={
                "card_payments": {"requested": True},
                "transfers": {"requested": True}
            },
            business_type="individual",
            individual={
                "first_name": vendor_data.first_name,
                "last_name": vendor_data.last_name,
                "email": vendor_data.email
            }
        )

        # Create account link for onboarding
        account_link = await stripe.AccountLink.create(
            account=account.id,
            refresh_url=self.refresh_url,
            return_url=self.return_url,
            type="account_onboarding"
        )

        return account, account_link
```

## –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –ø—Ä–æ–µ–∫—Ç–∞–º–∏

### Framework Integration Examples

#### FastAPI Integration
```python
from fastapi import FastAPI, Request, HTTPException
from payment_integration_agent import PaymentAgentDependencies, get_payment_integration_agent

app = FastAPI()

# Initialize payment agent
payment_deps = PaymentAgentDependencies(
    api_key=os.getenv("STRIPE_SECRET_KEY"),
    payment_provider="stripe",
    business_model="ecommerce"
)

payment_agent = get_payment_integration_agent(payment_deps)

@app.post("/payments")
async def create_payment(payment_request: PaymentRequest):
    try:
        result = await payment_agent.run(
            f"Create payment for {payment_request.amount} {payment_request.currency}",
            deps=payment_deps
        )
        return {"success": True, "data": result.data}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/webhooks/stripe")
async def handle_stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    verification_result = await validate_webhook_event(
        payload.decode(), sig_header, payment_deps
    )

    if verification_result["verified"]:
        # Process the event
        return {"status": "processed"}
    else:
        raise HTTPException(status_code=400, detail="Invalid signature")
```

#### Express.js Integration
```javascript
const express = require('express');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const app = express();

app.post('/payments', async (req, res) => {
    try {
        const { amount, currency, payment_method_id } = req.body;

        const paymentIntent = await stripe.paymentIntents.create({
            amount: amount * 100, // Convert to cents
            currency,
            payment_method: payment_method_id,
            confirmation_method: 'manual',
            confirm: true
        });

        res.json({
            success: true,
            client_secret: paymentIntent.client_secret
        });
    } catch (error) {
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/webhooks/stripe', express.raw({type: 'application/json'}), (req, res) => {
    const sig = req.headers['stripe-signature'];
    let event;

    try {
        event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
    } catch (err) {
        return res.status(400).send(`Webhook signature verification failed.`);
    }

    // Handle the event
    switch (event.type) {
        case 'payment_intent.succeeded':
            // Handle successful payment
            break;
        case 'payment_intent.payment_failed':
            // Handle failed payment
            break;
        default:
            console.log(`Unhandled event type ${event.type}`);
    }

    res.json({received: true});
});
```

### Best Practices –∏ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

#### Error Handling
```python
class PaymentErrorHandler:
    def __init__(self):
        self.error_mappings = {
            "card_declined": "Your card was declined. Please try a different payment method.",
            "insufficient_funds": "Insufficient funds. Please check your account balance.",
            "expired_card": "Your card has expired. Please use a different payment method.",
            "processing_error": "We encountered an error processing your payment. Please try again."
        }

    def handle_payment_error(self, error):
        error_code = self.extract_error_code(error)
        user_message = self.error_mappings.get(
            error_code,
            "An unexpected error occurred. Please try again."
        )

        # Log detailed error for debugging
        logger.error(f"Payment error: {error_code}", extra={
            "error": str(error),
            "stack_trace": traceback.format_exc()
        })

        return {
            "success": False,
            "error_code": error_code,
            "message": user_message
        }
```

#### Performance Optimization
```python
class PaymentPerformanceOptimizer:
    def __init__(self):
        self.cache = RedisCache()
        self.circuit_breaker = CircuitBreaker()

    @cached(ttl=300)  # Cache for 5 minutes
    async def get_exchange_rates(self):
        return await self.exchange_rate_service.get_rates()

    @circuit_breaker.protected
    async def process_payment(self, payment_data):
        # Circuit breaker protects against cascading failures
        return await self.payment_provider.create_payment(payment_data)

    async def batch_process_payments(self, payments):
        # Process payments in batches for better performance
        batch_size = 10
        results = []

        for i in range(0, len(payments), batch_size):
            batch = payments[i:i + batch_size]
            batch_results = await asyncio.gather(
                *[self.process_payment(payment) for payment in batch],
                return_exceptions=True
            )
            results.extend(batch_results)

        return results
```

## Recommended Resources

### Documentation Links
- **Stripe**: https://stripe.com/docs
- **PayPal**: https://developer.paypal.com/docs/
- **Square**: https://developer.squareup.com/docs
- **Razorpay**: https://razorpay.com/docs/
- **Braintree**: https://developers.braintreepayments.com/
- **Adyen**: https://docs.adyen.com/

### Compliance Resources
- **PCI DSS**: https://www.pcisecuritystandards.org/
- **GDPR**: https://gdpr-info.eu/
- **PSD2**: https://ec.europa.eu/info/law/payment-services-psd-2-directive-eu-2015-2366_en

### Testing Resources
- **Stripe Test Cards**: https://stripe.com/docs/testing
- **PayPal Sandbox**: https://developer.paypal.com/docs/api-basics/sandbox/
- **Webhook Testing**: https://webhook.site/